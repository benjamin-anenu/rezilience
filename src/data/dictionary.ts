export interface DictionaryEntry {
  id: string;
  term: string;
  abbreviation?: string;
  category: DictionaryCategory;
  definition: string;
  whenToUse: string;
  example: string;
  relatedTerms: string[];
}

export type DictionaryCategory =
  | 'Accounts'
  | 'Transactions'
  | 'DeFi'
  | 'NFTs'
  | 'Governance'
  | 'Infrastructure'
  | 'Security'
  | 'Tokens'
  | 'Consensus'
  | 'Development';

export const dictionaryCategories: DictionaryCategory[] = [
  'Accounts',
  'Transactions',
  'DeFi',
  'NFTs',
  'Governance',
  'Infrastructure',
  'Security',
  'Tokens',
  'Consensus',
  'Development',
];

export const dictionary: DictionaryEntry[] = [
  {
    id: 'pda',
    term: 'Program Derived Address',
    abbreviation: 'PDA',
    category: 'Accounts',
    definition: 'An account address deterministically derived from a program ID and a set of seeds. PDAs are not on the Ed25519 curve, meaning no private key exists for them — only the owning program can sign on their behalf.',
    whenToUse: 'When your program needs to own accounts or sign transactions without a private key. Common for escrow accounts, vaults, and protocol-owned state.',
    example: `const [pda, bump] = PublicKey.findProgramAddressSync(\n  [Buffer.from("vault"), userPubkey.toBuffer()],\n  programId\n);`,
    relatedTerms: ['seeds', 'bump-seed', 'cpi'],
  },
  {
    id: 'seeds',
    term: 'Seeds',
    category: 'Accounts',
    definition: 'Byte arrays used as inputs to derive a PDA. Seeds make each PDA unique and predictable — anyone who knows the seeds and program ID can re-derive the same address.',
    whenToUse: 'When deriving PDAs. Use meaningful seeds (e.g., user pubkey + "vault") so the address can be found without storing it.',
    example: `// Seeds: ["user-profile", wallet_address]\nlet seeds = &[b"user-profile", user.key().as_ref()];`,
    relatedTerms: ['pda', 'bump-seed'],
  },
  {
    id: 'bump-seed',
    term: 'Bump Seed',
    category: 'Accounts',
    definition: 'A single byte (0-255) appended to seeds to push a derived address off the Ed25519 curve, making it a valid PDA. The runtime tries bump values from 255 down to 0 until a valid PDA is found.',
    whenToUse: 'Always stored alongside a PDA so you don\'t recompute it. Anchor handles this automatically with the `bump` constraint.',
    example: `#[account(\n  seeds = [b"config"],\n  bump = config.bump,\n)]\npub config: Account<'info, Config>,`,
    relatedTerms: ['pda', 'seeds'],
  },
  {
    id: 'cpi',
    term: 'Cross-Program Invocation',
    abbreviation: 'CPI',
    category: 'Transactions',
    definition: 'A mechanism that allows one Solana program to call another program\'s instructions within a single transaction. The calling program can pass its signer privileges to the callee.',
    whenToUse: 'When your program needs to interact with another on-chain program — e.g., transferring SOL via the System Program or minting tokens via the Token Program.',
    example: `// CPI to transfer SOL\nanchor_lang::system_program::transfer(\n  CpiContext::new(system_program, Transfer {\n    from: sender.to_account_info(),\n    to: receiver.to_account_info(),\n  }),\n  amount,\n)?;`,
    relatedTerms: ['pda', 'instruction', 'signer'],
  },
  {
    id: 'lamports',
    term: 'Lamports',
    category: 'Tokens',
    definition: 'The smallest unit of SOL. 1 SOL = 1,000,000,000 (1 billion) lamports. Named after Leslie Lamport, a computer scientist known for distributed systems research.',
    whenToUse: 'All on-chain SOL amounts are expressed in lamports. Always convert when displaying to users: `balance / LAMPORTS_PER_SOL`.',
    example: `import { LAMPORTS_PER_SOL } from '@solana/web3.js';\nconst solBalance = lamports / LAMPORTS_PER_SOL;`,
    relatedTerms: ['sol', 'rent'],
  },
  {
    id: 'rent',
    term: 'Rent',
    category: 'Accounts',
    definition: 'A fee charged to keep accounts alive on Solana. Accounts must maintain a minimum SOL balance (rent-exempt threshold) proportional to their data size. If below this threshold, the account is garbage-collected.',
    whenToUse: 'When creating accounts, always fund them to be rent-exempt. Use `getMinimumBalanceForRentExemption()` to calculate the required lamports.',
    example: `const rentExempt = await connection.getMinimumBalanceForRentExemption(dataSize);\n// Fund the account with at least this amount`,
    relatedTerms: ['lamports', 'account', 'space'],
  },
  {
    id: 'account',
    term: 'Account',
    category: 'Accounts',
    definition: 'The fundamental storage unit on Solana. Everything is an account — wallets, programs, data. Each account has an owner (program), balance (lamports), data (byte array), and executable flag.',
    whenToUse: 'Understanding accounts is foundational. Wallets are accounts owned by the System Program. Program state is stored in accounts owned by your program.',
    example: `// Account structure\n{\n  lamports: 1000000,\n  data: Buffer<...>,\n  owner: PublicKey,\n  executable: false,\n  rentEpoch: 361\n}`,
    relatedTerms: ['rent', 'pda', 'space'],
  },
  {
    id: 'space',
    term: 'Space',
    category: 'Accounts',
    definition: 'The number of bytes allocated for an account\'s data field. Must be specified at account creation and determines the rent-exempt cost. Anchor calculates this from your struct definition.',
    whenToUse: 'When creating accounts with `init`. Calculate as: 8 (discriminator) + sum of field sizes. Anchor uses `#[account(init, space = 8 + MyStruct::INIT_SPACE)]`.',
    example: `#[account]\npub struct Counter {\n  pub count: u64,     // 8 bytes\n  pub authority: Pubkey, // 32 bytes\n}\n// Total space: 8 + 8 + 32 = 48 bytes`,
    relatedTerms: ['account', 'rent', 'discriminator'],
  },
  {
    id: 'discriminator',
    term: 'Discriminator',
    category: 'Development',
    definition: 'An 8-byte identifier prepended to every Anchor account\'s data. It\'s the first 8 bytes of the SHA-256 hash of the account\'s type name. Prevents deserialization of wrong account types.',
    whenToUse: 'Anchor handles this automatically. Be aware of it when calculating account space (always add 8 bytes) or when reading raw account data.',
    example: `// Anchor auto-generates discriminator\n// For "Counter" account: sha256("account:Counter")[0..8]`,
    relatedTerms: ['space', 'account', 'anchor'],
  },
  {
    id: 'instruction',
    term: 'Instruction',
    category: 'Transactions',
    definition: 'A single operation within a transaction. Contains the target program ID, a list of accounts the instruction will read/write, and serialized instruction data. Multiple instructions can be batched into one transaction.',
    whenToUse: 'Every interaction with a Solana program goes through instructions. Batch related operations into a single transaction for atomicity.',
    example: `const ix = new TransactionInstruction({\n  programId: myProgramId,\n  keys: [\n    { pubkey: user, isSigner: true, isWritable: true },\n  ],\n  data: Buffer.from([...]),\n});`,
    relatedTerms: ['transaction', 'cpi', 'signer'],
  },
  {
    id: 'transaction',
    term: 'Transaction',
    category: 'Transactions',
    definition: 'An atomic unit of execution on Solana containing one or more instructions. All instructions either succeed or fail together. Transactions have a 1232-byte size limit and require at least one signer.',
    whenToUse: 'Group related instructions into a single transaction for atomicity. If you exceed the size limit, use Versioned Transactions with Address Lookup Tables.',
    example: `const tx = new Transaction().add(ix1, ix2);\ntx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\ntx.feePayer = wallet.publicKey;\nawait wallet.signTransaction(tx);`,
    relatedTerms: ['instruction', 'blockhash', 'versioned-transaction'],
  },
  {
    id: 'blockhash',
    term: 'Blockhash',
    category: 'Transactions',
    definition: 'A recent hash from the Solana ledger that acts as a transaction\'s timestamp. Transactions with blockhashes older than ~60-90 seconds are rejected, preventing replay attacks.',
    whenToUse: 'Always fetch a fresh blockhash before submitting a transaction. Use `getLatestBlockhash()` and set `lastValidBlockHeight` for confirmation tracking.',
    example: `const { blockhash, lastValidBlockHeight } = \n  await connection.getLatestBlockhash();\ntx.recentBlockhash = blockhash;`,
    relatedTerms: ['transaction', 'slot'],
  },
  {
    id: 'versioned-transaction',
    term: 'Versioned Transaction',
    category: 'Transactions',
    definition: 'A newer transaction format (v0) that supports Address Lookup Tables (ALTs), allowing transactions to reference more accounts without exceeding the size limit. Essential for complex DeFi operations.',
    whenToUse: 'When your transaction needs more than ~35 accounts or exceeds the 1232-byte limit. Jupiter and most DeFi protocols return versioned transactions.',
    example: `import { VersionedTransaction } from '@solana/web3.js';\nconst tx = VersionedTransaction.deserialize(serializedTx);\nawait wallet.signTransaction(tx);`,
    relatedTerms: ['transaction', 'address-lookup-table'],
  },
  {
    id: 'address-lookup-table',
    term: 'Address Lookup Table',
    abbreviation: 'ALT',
    category: 'Transactions',
    definition: 'An on-chain table that stores frequently-used account addresses. Versioned transactions reference ALT entries by index (1 byte) instead of full pubkey (32 bytes), dramatically reducing transaction size.',
    whenToUse: 'When building complex transactions that reference many accounts. Most DEX aggregators use ALTs. Create your own for protocols with many repeated accounts.',
    example: `const lookupTable = (await connection.getAddressLookupTable(tableAddress)).value;\n// Use in VersionedTransaction.compile()`,
    relatedTerms: ['versioned-transaction', 'transaction'],
  },
  {
    id: 'slot',
    term: 'Slot',
    category: 'Consensus',
    definition: 'A time window (~400ms) during which a validator can produce a block. Slots are sequential and used to measure time on Solana. Not every slot produces a block (some are skipped).',
    whenToUse: 'For timing and ordering. Use slot numbers for relative ordering of events. Epoch = 432,000 slots (~2-3 days).',
    example: `const slot = await connection.getSlot();\nconsole.log('Current slot:', slot);`,
    relatedTerms: ['epoch', 'blockhash', 'validator'],
  },
  {
    id: 'epoch',
    term: 'Epoch',
    category: 'Consensus',
    definition: 'A period of 432,000 slots (~2-3 days) during which the validator schedule is fixed. Stake delegations take effect at epoch boundaries, and rewards are distributed at the end of each epoch.',
    whenToUse: 'Relevant for staking operations. Stake activation/deactivation takes 1 full epoch. Use `getEpochInfo()` to check current epoch progress.',
    example: `const epochInfo = await connection.getEpochInfo();\nconsole.log('Epoch:', epochInfo.epoch, 'Slot in epoch:', epochInfo.slotIndex);`,
    relatedTerms: ['slot', 'validator', 'stake'],
  },
  {
    id: 'validator',
    term: 'Validator',
    category: 'Consensus',
    definition: 'A node that participates in the Solana network by verifying transactions and producing blocks. Validators stake SOL and earn rewards. The leader schedule rotates validators for block production.',
    whenToUse: 'Understanding validators matters for staking (choosing where to delegate) and for RPC reliability (some validators run public RPC endpoints).',
    example: `const validators = await connection.getVoteAccounts();\nconsole.log('Active validators:', validators.current.length);`,
    relatedTerms: ['slot', 'epoch', 'stake'],
  },
  {
    id: 'spl-token',
    term: 'SPL Token',
    category: 'Tokens',
    definition: 'The standard token program on Solana (Solana Program Library). Handles creating, minting, transferring, and burning fungible and non-fungible tokens. Every token on Solana uses this program.',
    whenToUse: 'Any token operation — creating a new token, minting supply, transferring between wallets. Use Token-2022 for advanced features like transfer hooks.',
    example: `import { createMint, mintTo } from '@solana/spl-token';\n\nconst mint = await createMint(\n  connection, payer, authority, null, 9\n);\nawait mintTo(connection, payer, mint, tokenAccount, authority, 1000000000);`,
    relatedTerms: ['token-2022', 'mint', 'associated-token-account'],
  },
  {
    id: 'token-2022',
    term: 'Token-2022 (Token Extensions)',
    category: 'Tokens',
    definition: 'The next-generation token program with extensions like transfer fees, confidential transfers, interest-bearing tokens, permanent delegates, and transfer hooks. Backwards-compatible with SPL Token.',
    whenToUse: 'When you need features not available in the original SPL Token: royalty enforcement, compliance hooks, interest accrual, or non-transferable tokens.',
    example: `// Create a mint with transfer fee extension\nimport { createInitializeTransferFeeConfigInstruction } from '@solana/spl-token';`,
    relatedTerms: ['spl-token', 'mint', 'transfer-hook'],
  },
  {
    id: 'mint',
    term: 'Mint',
    category: 'Tokens',
    definition: 'An account that defines a token type. It stores the total supply, decimal places, and the mint authority (who can create new tokens). Each unique token on Solana has exactly one mint account.',
    whenToUse: 'When creating a new token or referencing an existing one. The mint address is the token\'s unique identifier (like a contract address on Ethereum).',
    example: `// USDC mint on mainnet\nconst USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');`,
    relatedTerms: ['spl-token', 'associated-token-account'],
  },
  {
    id: 'associated-token-account',
    term: 'Associated Token Account',
    abbreviation: 'ATA',
    category: 'Tokens',
    definition: 'A deterministically-derived token account for a specific wallet and mint. The ATA program ensures each wallet has exactly one token account per mint at a predictable address.',
    whenToUse: 'Always use ATAs for user-facing token operations. The address is derived from the wallet and mint, so you never need to store it separately.',
    example: `import { getAssociatedTokenAddress } from '@solana/spl-token';\n\nconst ata = await getAssociatedTokenAddress(mintPubkey, walletPubkey);\n// Always the same for this wallet + mint combination`,
    relatedTerms: ['mint', 'spl-token', 'pda'],
  },
  {
    id: 'amm',
    term: 'Automated Market Maker',
    abbreviation: 'AMM',
    category: 'DeFi',
    definition: 'A protocol that uses mathematical formulas (typically x*y=k) to price assets in a liquidity pool, enabling decentralized trading without order books. Examples: Orca, Raydium.',
    whenToUse: 'When providing or consuming liquidity for token swaps. Use Jupiter to aggregate across AMMs for best pricing.',
    example: `// Swap via Jupiter (aggregates across AMMs)\nconst quote = await jupiterApi.quoteGet({\n  inputMint: SOL_MINT,\n  outputMint: USDC_MINT,\n  amount: 1_000_000_000,\n});`,
    relatedTerms: ['liquidity-pool', 'slippage', 'impermanent-loss'],
  },
  {
    id: 'liquidity-pool',
    term: 'Liquidity Pool',
    abbreviation: 'LP',
    category: 'DeFi',
    definition: 'A smart contract holding reserves of two or more tokens that enables trading. Liquidity providers deposit tokens and earn fees from swaps. The pool\'s reserves determine the exchange rate.',
    whenToUse: 'When building or integrating with DEXs. Provide liquidity to earn trading fees, or use pools for token swaps.',
    example: `// Check pool reserves\nconst poolInfo = await fetchPoolData(poolAddress);\nconsole.log('Token A:', poolInfo.tokenAReserve);\nconsole.log('Token B:', poolInfo.tokenBReserve);`,
    relatedTerms: ['amm', 'impermanent-loss', 'tvl'],
  },
  {
    id: 'tvl',
    term: 'Total Value Locked',
    abbreviation: 'TVL',
    category: 'DeFi',
    definition: 'The total USD value of assets deposited in a DeFi protocol. TVL is a key metric for gauging protocol adoption and trust — higher TVL generally indicates more market confidence.',
    whenToUse: 'For evaluating DeFi protocols. Compare TVL across protocols to assess relative adoption. Track TVL changes as a signal of capital flows.',
    example: `// Fetch TVL from DeFi Llama\nconst response = await fetch('https://api.llama.fi/tvl/protocol-name');\nconst tvl = await response.json();`,
    relatedTerms: ['liquidity-pool', 'amm'],
  },
  {
    id: 'slippage',
    term: 'Slippage',
    category: 'DeFi',
    definition: 'The difference between the expected price of a trade and the actual execution price. Caused by price movement between submission and execution, or insufficient liquidity in the pool.',
    whenToUse: 'Always set slippage tolerance when executing swaps. 0.5% is typical for stable pairs; 1-3% for volatile pairs. Too low = failed transactions; too high = sandwich attack risk.',
    example: `// Set slippage to 50 basis points (0.5%)\nconst quote = await jupiterApi.quoteGet({\n  ...params,\n  slippageBps: 50,\n});`,
    relatedTerms: ['amm', 'mev'],
  },
  {
    id: 'mev',
    term: 'Maximal Extractable Value',
    abbreviation: 'MEV',
    category: 'DeFi',
    definition: 'Profit extracted by reordering, inserting, or censoring transactions within a block. On Solana, MEV primarily manifests as sandwich attacks (front-running + back-running a swap) and arbitrage.',
    whenToUse: 'Be aware of MEV when submitting large swaps. Use Jito tips for priority inclusion, or set tight slippage to minimize sandwich attack profit.',
    example: `// Use Jito for MEV-protected transactions\n// Tip validators for priority inclusion\nconst jitoTip = 10_000; // lamports`,
    relatedTerms: ['slippage', 'jito'],
  },
  {
    id: 'idl',
    term: 'Interface Definition Language',
    abbreviation: 'IDL',
    category: 'Development',
    definition: 'A JSON file generated by Anchor that describes a program\'s instructions, accounts, types, and errors. Clients use the IDL to auto-generate type-safe interaction code.',
    whenToUse: 'When building clients for Anchor programs. Import the IDL to get typed methods: `program.methods.initialize().accounts({...}).rpc()`.',
    example: `import idl from './my_program.json';\nconst program = new Program(idl, programId, provider);\nawait program.methods.initialize().accounts({...}).rpc();`,
    relatedTerms: ['anchor', 'instruction'],
  },
  {
    id: 'anchor',
    term: 'Anchor',
    category: 'Development',
    definition: 'The dominant framework for building Solana programs in Rust. Provides macros for account validation, serialization, error handling, and testing. Think of it as Rails for Solana.',
    whenToUse: 'For almost all new Solana programs. Reduces boilerplate by 60-80% compared to raw Solana SDK. Only skip Anchor for maximum compute optimization.',
    example: `#[program]\npub mod my_program {\n  pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n    ctx.accounts.counter.count = 0;\n    Ok(())\n  }\n}`,
    relatedTerms: ['idl', 'cpi', 'discriminator'],
  },
  {
    id: 'signer',
    term: 'Signer',
    category: 'Transactions',
    definition: 'An account that has cryptographically signed a transaction, proving ownership. Signers authorize state changes — e.g., transferring SOL requires the sender\'s signature.',
    whenToUse: 'Mark accounts as signers in instructions when the program needs to verify authority. In Anchor, use `Signer<\'info>` for required signers.',
    example: `#[derive(Accounts)]\npub struct Transfer<'info> {\n  #[account(mut)]\n  pub from: Signer<'info>, // Must sign the transaction\n  #[account(mut)]\n  pub to: SystemAccount<'info>,\n}`,
    relatedTerms: ['transaction', 'instruction', 'keypair'],
  },
  {
    id: 'keypair',
    term: 'Keypair',
    category: 'Accounts',
    definition: 'A pair of cryptographic keys (public + private) based on the Ed25519 curve. The public key serves as an account address; the private key proves ownership and enables signing.',
    whenToUse: 'For server-side signing (bots, scripts) or generating new accounts. Never expose private keys in client-side code — use wallet adapters instead.',
    example: `import { Keypair } from '@solana/web3.js';\nconst kp = Keypair.generate();\nconsole.log('Public:', kp.publicKey.toBase58());\n// NEVER log kp.secretKey in production!`,
    relatedTerms: ['signer', 'account', 'pda'],
  },
  {
    id: 'nft',
    term: 'Non-Fungible Token',
    abbreviation: 'NFT',
    category: 'NFTs',
    definition: 'A unique digital asset represented as a token with supply of 1 and 0 decimals. On Solana, NFTs follow the Metaplex Token Metadata standard and can include on-chain attributes, royalties, and collection grouping.',
    whenToUse: 'For unique digital assets — art, tickets, memberships, in-game items. Use Metaplex for standard NFTs or Bubblegum for compressed NFTs (cheaper at scale).',
    example: `// Fetch NFT metadata using Helius DAS API\nconst nft = await helius.rpc.getAsset({ id: mintAddress });\nconsole.log(nft.content.metadata.name);`,
    relatedTerms: ['metaplex', 'compressed-nft', 'mint'],
  },
  {
    id: 'compressed-nft',
    term: 'Compressed NFT',
    abbreviation: 'cNFT',
    category: 'NFTs',
    definition: 'NFTs stored using state compression (Merkle trees) instead of individual accounts. Reduces minting cost from ~$2 to ~$0.0005 per NFT. Data is stored off-chain with on-chain proof.',
    whenToUse: 'When minting at scale (10k+ NFTs). Gaming items, loyalty points, event tickets. Use the DAS API (Helius, Triton) to read compressed NFT data.',
    example: `// Minting 1M compressed NFTs costs ~$500\n// vs $2M for uncompressed NFTs\nimport { createTree, mintToCollectionV1 } from '@metaplex-foundation/mpl-bubblegum';`,
    relatedTerms: ['nft', 'state-compression', 'merkle-tree'],
  },
  {
    id: 'state-compression',
    term: 'State Compression',
    category: 'Infrastructure',
    definition: 'A technique that stores data off-chain while maintaining on-chain Merkle tree proofs for verification. Dramatically reduces costs for large datasets. Powers compressed NFTs and potentially other compressed state.',
    whenToUse: 'When you need to store millions of records cheaply. Currently used primarily for compressed NFTs via the Bubblegum program.',
    example: `// Create a Merkle tree for state compression\nconst tree = await createTree(umi, {\n  merkleTree,\n  maxDepth: 14,      // 16,384 leaves\n  maxBufferSize: 64,\n});`,
    relatedTerms: ['compressed-nft', 'merkle-tree'],
  },
  {
    id: 'merkle-tree',
    term: 'Merkle Tree',
    category: 'Infrastructure',
    definition: 'A binary tree where each leaf contains data and each parent node contains the hash of its children. Enables efficient proof-of-inclusion — you can verify a leaf exists without downloading the entire tree.',
    whenToUse: 'Understanding Merkle trees helps when working with state compression or building systems that need efficient data verification (airdrops, whitelists).',
    example: `// A tree with maxDepth=20 supports 1,048,576 leaves\n// Proof size is only 20 hashes regardless of total leaves`,
    relatedTerms: ['state-compression', 'compressed-nft'],
  },
  {
    id: 'rpc',
    term: 'Remote Procedure Call',
    abbreviation: 'RPC',
    category: 'Infrastructure',
    definition: 'The API interface for interacting with a Solana validator node. RPC endpoints handle requests like getBalance, sendTransaction, and getAccountInfo. Public endpoints exist but are rate-limited.',
    whenToUse: 'Every Solana app needs an RPC endpoint. Use public for development; switch to Helius, QuickNode, or Triton for production to avoid rate limits and get enhanced APIs.',
    example: `import { Connection } from '@solana/web3.js';\n// Development\nconst dev = new Connection('https://api.devnet.solana.com');\n// Production (use private RPC)\nconst prod = new Connection('https://rpc.helius.xyz/?api-key=YOUR_KEY');`,
    relatedTerms: ['validator', 'websocket'],
  },
  {
    id: 'multisig',
    term: 'Multisig',
    category: 'Governance',
    definition: 'A wallet that requires multiple signatures (M-of-N) to approve transactions. On Solana, Squads Protocol is the standard multisig implementation, supporting program upgrades, treasury management, and governance.',
    whenToUse: 'For protocol treasuries, program upgrade authorities, and any high-value operations. Production protocols should never have a single-key upgrade authority.',
    example: `// Create a 2-of-3 multisig with Squads\nconst multisig = await squads.createMultisig({\n  threshold: 2,\n  members: [memberA, memberB, memberC],\n});`,
    relatedTerms: ['governance', 'program-authority'],
  },
  {
    id: 'governance',
    term: 'Governance',
    category: 'Governance',
    definition: 'On-chain voting mechanisms that allow token holders to propose and vote on protocol changes. Solana uses SPL Governance (Realms) for DAO-style governance with delegation, quorums, and time-locks.',
    whenToUse: 'When building DAOs or decentralizing protocol control. Use Realms for standard governance or build custom governance with Anchor.',
    example: `// Realms governance\n// Create proposal → Community votes → Execute if passed\n// https://realms.today`,
    relatedTerms: ['multisig', 'dao', 'realms'],
  },
  {
    id: 'dao',
    term: 'Decentralized Autonomous Organization',
    abbreviation: 'DAO',
    category: 'Governance',
    definition: 'An organization governed by smart contracts and token-holder voting rather than traditional management. Members propose, vote on, and automatically execute decisions through on-chain governance.',
    whenToUse: 'When building community-governed protocols. Use SPL Governance (Realms) for a battle-tested implementation with council and community voting.',
    example: `// Popular Solana DAOs use Realms:\n// - Marinade Finance\n// - Mango Markets\n// - Jito\n// Visit realms.today to explore`,
    relatedTerms: ['governance', 'multisig', 'realms'],
  },
  {
    id: 'program-authority',
    term: 'Program Authority (Upgrade Authority)',
    category: 'Security',
    definition: 'The keypair or multisig authorized to upgrade a deployed Solana program. If set to null, the program becomes immutable — no further upgrades are possible.',
    whenToUse: 'Audit this before trusting a protocol. Production programs should use a multisig authority. Immutable programs are maximally trustworthy but cannot be patched.',
    example: `# Check upgrade authority\nsolana program show <PROGRAM_ID>\n# Transfer to multisig\nsolana program set-upgrade-authority <PROGRAM_ID> --new-upgrade-authority <MULTISIG>`,
    relatedTerms: ['multisig', 'governance'],
  },
  {
    id: 'sol',
    term: 'SOL',
    category: 'Tokens',
    definition: 'The native token of the Solana blockchain. Used for transaction fees, staking, and rent. SOL is divisible to 9 decimal places (1 SOL = 10^9 lamports).',
    whenToUse: 'Every Solana transaction requires SOL for fees (~0.000005 SOL per signature). Users need SOL in their wallet before interacting with any dApp.',
    example: `// Airdrop SOL on devnet for testing\nawait connection.requestAirdrop(publicKey, 2 * LAMPORTS_PER_SOL);`,
    relatedTerms: ['lamports', 'stake', 'rent'],
  },
  {
    id: 'stake',
    term: 'Stake / Staking',
    category: 'Consensus',
    definition: 'Delegating SOL to a validator to help secure the network. Stakers earn rewards (~6-8% APY) proportional to their stake. Delegated stake takes one epoch to activate and one to deactivate.',
    whenToUse: 'For earning yield on SOL holdings. Liquid staking (mSOL, jitoSOL, bSOL) lets you stake while keeping liquidity for DeFi.',
    example: `// Liquid staking with Marinade\n// Deposit SOL → Receive mSOL (staked SOL derivative)\n// mSOL accrues staking rewards automatically`,
    relatedTerms: ['validator', 'epoch', 'sol'],
  },
  {
    id: 'impermanent-loss',
    term: 'Impermanent Loss',
    abbreviation: 'IL',
    category: 'DeFi',
    definition: 'The loss in value a liquidity provider experiences when the price ratio of pooled tokens changes compared to simply holding them. Called "impermanent" because it reverses if prices return to the original ratio.',
    whenToUse: 'Evaluate IL risk before providing liquidity. Concentrated liquidity (Orca Whirlpools) amplifies both fees AND IL. Stable pairs have minimal IL.',
    example: `// If SOL doubles in price:\n// Holding: $200 worth\n// LP position: ~$183 worth (8.5% IL)\n// But you also earned trading fees`,
    relatedTerms: ['liquidity-pool', 'amm'],
  },
  {
    id: 'devnet',
    term: 'Devnet',
    category: 'Infrastructure',
    definition: 'Solana\'s development test network. Free SOL can be airdropped for testing. Programs deployed to devnet are separate from mainnet. Use for development and testing before mainnet deployment.',
    whenToUse: 'Always develop and test on devnet first. Use `solana config set --url devnet` to switch your CLI. Request airdrops for test SOL.',
    example: `// Connect to devnet\nconst connection = new Connection('https://api.devnet.solana.com');\n// Get free test SOL\nawait connection.requestAirdrop(pubkey, LAMPORTS_PER_SOL);`,
    relatedTerms: ['mainnet', 'rpc'],
  },
  {
    id: 'mainnet',
    term: 'Mainnet-Beta',
    category: 'Infrastructure',
    definition: 'Solana\'s production network where real value transactions occur. Called "mainnet-beta" historically. Use a private RPC endpoint for production apps to avoid rate limits on the public endpoint.',
    whenToUse: 'For production deployments. Always test thoroughly on devnet first. Use a dedicated RPC provider (Helius, QuickNode) for reliability.',
    example: `// Production connection with private RPC\nconst connection = new Connection(\n  'https://rpc.helius.xyz/?api-key=YOUR_KEY',\n  'confirmed'\n);`,
    relatedTerms: ['devnet', 'rpc'],
  },
  {
    id: 'priority-fees',
    term: 'Priority Fees',
    category: 'Transactions',
    definition: 'Optional fees added to a transaction to incentivize validators to process it faster. Measured in micro-lamports per compute unit. Essential during network congestion or for time-sensitive operations.',
    whenToUse: 'For time-sensitive transactions (arbitrage, liquidations) or during high congestion. Use `getRecentPrioritizationFees()` to estimate appropriate levels.',
    example: `import { ComputeBudgetProgram } from '@solana/web3.js';\nconst priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({\n  microLamports: 50_000, // Adjust based on network conditions\n});`,
    relatedTerms: ['compute-units', 'transaction'],
  },
  {
    id: 'compute-units',
    term: 'Compute Units',
    abbreviation: 'CU',
    category: 'Transactions',
    definition: 'A measure of computational resources consumed by a transaction. Each transaction has a budget (default 200k CU, max 1.4M CU). Programs that exceed their budget are halted. Optimizing CU usage reduces priority fees.',
    whenToUse: 'When optimizing program performance. Request only the CU you need with `setComputeUnitLimit()` to avoid overpaying priority fees.',
    example: `const computeLimitIx = ComputeBudgetProgram.setComputeUnitLimit({\n  units: 300_000, // Request specific CU budget\n});`,
    relatedTerms: ['priority-fees', 'transaction'],
  },
  {
    id: 'websocket',
    term: 'WebSocket (Subscriptions)',
    category: 'Infrastructure',
    definition: 'A persistent connection to a Solana RPC node for real-time updates. Subscribe to account changes, log messages, signatures, and slot updates without polling.',
    whenToUse: 'For real-time UIs — wallet balance updates, transaction confirmations, live price feeds. More efficient than polling for frequent updates.',
    example: `// Subscribe to account changes\nconnection.onAccountChange(publicKey, (accountInfo) => {\n  console.log('Account changed:', accountInfo.lamports);\n});`,
    relatedTerms: ['rpc'],
  },
  {
    id: 'transfer-hook',
    term: 'Transfer Hook',
    category: 'Tokens',
    definition: 'A Token-2022 extension that calls a custom program whenever a token is transferred. Enables royalty enforcement, compliance checks, transfer restrictions, and custom logic on every token movement.',
    whenToUse: 'When you need code to execute on every token transfer — e.g., enforcing creator royalties, KYC checks, or updating game state.',
    example: `// Transfer hooks are configured at mint creation\n// Every transfer() call will invoke your hook program\n// Use for: royalties, compliance, gaming mechanics`,
    relatedTerms: ['token-2022', 'spl-token'],
  },
  {
    id: 'realms',
    term: 'Realms',
    category: 'Governance',
    definition: 'The standard governance UI and tooling for Solana DAOs, built on SPL Governance. Supports council voting, community voting, delegation, and on-chain proposal execution.',
    whenToUse: 'When setting up governance for your protocol. Realms provides a ready-made UI at realms.today — no custom frontend needed for basic governance.',
    example: `// Visit realms.today to:\n// - Create a new DAO\n// - Manage proposals\n// - Delegate voting power\n// - Execute approved transactions`,
    relatedTerms: ['dao', 'governance', 'multisig'],
  },

  // ═══════════════════════════════════════════════════
  // ACCOUNTS — 8 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'account-ownership-rules',
    term: 'Account Ownership Rules',
    category: 'Accounts',
    definition: 'Every Solana account has exactly one owning program. Only the owner can modify the account\'s data or debit its lamports. The System Program owns all wallet accounts; your program owns accounts it creates.',
    whenToUse: 'When debugging "account not owned by program" errors. Ensure accounts passed to your program are actually owned by it before deserialization.',
    example: `// Anchor enforces ownership automatically:\n#[account(\n  owner = my_program::ID // Verify owner\n)]\npub my_data: Account<'info, MyData>,\n// Manual check:\nif account.owner != program_id { return Err(ProgramError::IncorrectProgramId) }`,
    relatedTerms: ['account', 'pda', 'signer'],
  },
  {
    id: 'account-data-layout',
    term: 'Account Data Layout Design',
    category: 'Accounts',
    definition: 'The schema of bytes stored in a Solana account. Layout design affects space, rent cost, serialization performance, and upgrade flexibility. Anchor uses Borsh serialization with an 8-byte discriminator prefix.',
    whenToUse: 'When designing on-chain state. Put fixed-size fields first, variable-length fields (Vec, String) last. Plan for future fields to avoid account migration headaches.',
    example: `#[account]\npub struct GameState {\n  pub authority: Pubkey,    // 32 bytes (fixed)\n  pub score: u64,           // 8 bytes (fixed)\n  pub level: u8,            // 1 byte (fixed)\n  pub name: String,         // 4 + len bytes (variable, put last)\n}`,
    relatedTerms: ['space', 'discriminator', 'zero-copy-accounts'],
  },
  {
    id: 'zero-copy-accounts',
    term: 'Zero-Copy Accounts',
    category: 'Accounts',
    definition: 'A deserialization strategy that maps account data directly to a struct in memory without copying. Uses #[account(zero_copy)] in Anchor. Dramatically faster for large accounts (>1KB) but requires repr(C) layout.',
    whenToUse: 'For large accounts (order books, large arrays). Zero-copy avoids the serialization/deserialization overhead of Borsh. Fields must be fixed-size — no Vec or String.',
    example: `#[account(zero_copy)]\n#[repr(C)]\npub struct OrderBook {\n  pub orders: [Order; 256],  // Fixed-size array\n  pub head: u32,\n  pub count: u32,\n}`,
    relatedTerms: ['account-data-layout', 'space', 'borsh-serialization'],
  },
  {
    id: 'account-realloc',
    term: 'Account Realloc Patterns',
    category: 'Accounts',
    definition: 'The ability to resize an existing account\'s data field using realloc(). Anchor provides the `realloc` constraint to grow or shrink accounts, automatically handling rent adjustments.',
    whenToUse: 'When accounts need variable-size data that changes over time — e.g., adding items to an on-chain Vec. More efficient than closing and recreating accounts.',
    example: `#[account(\n  mut,\n  realloc = 8 + 32 + 4 + (items.len() + 1) * 32,\n  realloc::payer = payer,\n  realloc::zero = false,\n)]\npub my_list: Account<'info, ItemList>,`,
    relatedTerms: ['space', 'rent', 'account-data-layout'],
  },
  {
    id: 'writable-readonly-accounts',
    term: 'Writable vs Readonly Accounts',
    category: 'Accounts',
    definition: 'Each account in an instruction is marked writable or readonly. Writable accounts can have their data or lamports modified. Readonly accounts enable parallel execution — multiple transactions can read the same account simultaneously.',
    whenToUse: 'Mark accounts as writable only when necessary. Fewer writable accounts = better parallelism. Incorrect markings cause runtime errors or silent failures.',
    example: `keys: [\n  { pubkey: vault, isSigner: false, isWritable: true },   // modified\n  { pubkey: config, isSigner: false, isWritable: false }, // read only\n  { pubkey: owner, isSigner: true, isWritable: true },    // pays fees\n]`,
    relatedTerms: ['account-locking', 'signer', 'instruction'],
  },
  {
    id: 'account-locking',
    term: 'Account Locking & Parallel Execution',
    category: 'Accounts',
    definition: 'Solana\'s Sealevel runtime locks writable accounts during execution, preventing conflicts. Transactions touching different writable accounts run in parallel across CPU cores. This is Solana\'s key scalability mechanism.',
    whenToUse: 'Design programs to minimize shared writable state. Per-user PDAs instead of global state allows more parallelism. Hot accounts (global counters) become bottlenecks.',
    example: `// BAD: Global counter — serializes all transactions\n#[account(mut)] pub global_counter: Account<'info, Counter>,\n\n// GOOD: Per-user state — enables parallel execution\n#[account(mut, seeds = [b"user", signer.key().as_ref()], bump)]\npub user_state: Account<'info, UserState>,`,
    relatedTerms: ['writable-readonly-accounts', 'sealevel-runtime'],
  },
  {
    id: 'upgradeable-buffer',
    term: 'Upgradeable Buffer Accounts',
    category: 'Accounts',
    definition: 'Temporary accounts used during program deployment and upgrades. The program binary is first written to a buffer account, then atomically swapped into the program\'s data account by the upgrade authority.',
    whenToUse: 'Understanding the deployment pipeline. Buffer accounts can be reclaimed after deployment to recover rent SOL. Use `solana program close` to close orphaned buffers.',
    example: `# Write program to buffer\nsolana program write-buffer ./target/deploy/my_program.so\n# Deploy from buffer\nsolana program deploy --buffer <BUFFER_ADDRESS>\n# Close buffer to reclaim SOL\nsolana program close <BUFFER_ADDRESS>`,
    relatedTerms: ['program-authority', 'program-deployment-lifecycle'],
  },
  {
    id: 'durable-nonce',
    term: 'Durable Nonce Accounts',
    category: 'Accounts',
    definition: 'Special accounts that store a nonce value which can replace the recent blockhash in a transaction. Unlike blockhashes (which expire in ~60s), durable nonces remain valid until consumed, enabling offline/delayed signing.',
    whenToUse: 'For offline transaction signing, scheduled transactions, or multisig flows where collecting signatures takes longer than the blockhash lifetime.',
    example: `// Create a nonce account\nconst nonceAccount = Keypair.generate();\nconst tx = new Transaction().add(\n  SystemProgram.createNonceAccount({\n    fromPubkey: payer.publicKey,\n    noncePubkey: nonceAccount.publicKey,\n    authorizedPubkey: authority.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(NONCE_ACCOUNT_LENGTH),\n  })\n);`,
    relatedTerms: ['blockhash', 'offline-signing', 'multisig'],
  },

  // ═══════════════════════════════════════════════════
  // TRANSACTIONS — 11 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'tx-size-limits',
    term: 'Transaction Size Limits',
    category: 'Transactions',
    definition: 'Solana transactions are capped at 1232 bytes (fits in a single IPv6 MTU packet). This limits the number of accounts (~35 with legacy transactions) and instruction data per transaction. Versioned transactions with ALTs help mitigate this.',
    whenToUse: 'When hitting "transaction too large" errors. Reduce accounts with ALTs, split into multiple transactions, or compress instruction data.',
    example: `// Transaction budget:\n// - 1 byte: num signatures\n// - 64 bytes × N: signatures\n// - Message header: 3 bytes\n// - Account keys: 32 bytes each\n// - Blockhash: 32 bytes\n// - Instructions: variable\n// Total must be ≤ 1232 bytes`,
    relatedTerms: ['versioned-transaction', 'address-lookup-table', 'transaction'],
  },
  {
    id: 'atomic-transactions',
    term: 'Atomic Transaction Guarantees',
    category: 'Transactions',
    definition: 'All instructions in a Solana transaction succeed or fail together — there is no partial execution. If any instruction fails (CU exceeded, account constraint violated, custom error), the entire transaction is rolled back.',
    whenToUse: 'Leverage atomicity by batching related operations. E.g., swap + stake in one transaction ensures you don\'t end up with an intermediate state.',
    example: `// Atomic: both instructions succeed or neither does\nconst tx = new Transaction()\n  .add(swapInstruction)      // Step 1: swap USDC → SOL\n  .add(stakeInstruction);    // Step 2: stake the SOL\n// If staking fails, the swap is also reverted`,
    relatedTerms: ['transaction', 'instruction'],
  },
  {
    id: 'tx-simulation',
    term: 'Transaction Simulation vs Execution',
    category: 'Transactions',
    definition: 'Simulation runs a transaction against current state without committing changes. Returns logs, compute usage, and any errors. Execution actually commits the state changes to the ledger.',
    whenToUse: 'Always simulate before sending to catch errors early and estimate compute. Wallets like Phantom auto-simulate to show users the expected outcome.',
    example: `// Simulate to check for errors\nconst result = await connection.simulateTransaction(tx);\nif (result.value.err) {\n  console.error('Simulation failed:', result.value.logs);\n} else {\n  // Safe to send\n  await connection.sendTransaction(tx);\n}`,
    relatedTerms: ['preflight-checks', 'compute-units'],
  },
  {
    id: 'preflight-checks',
    term: 'Preflight Checks',
    category: 'Transactions',
    definition: 'Validation performed by the RPC node before forwarding a transaction to the leader. Checks include signature verification, blockhash validity, and optional transaction simulation. Can be skipped for speed.',
    whenToUse: 'Disable preflight with `skipPreflight: true` for latency-sensitive transactions (MEV, arbitrage). Keep enabled during development for better error messages.',
    example: `// Skip preflight for faster submission (use carefully)\nawait connection.sendRawTransaction(serializedTx, {\n  skipPreflight: true,\n  maxRetries: 3,\n});\n// Keep preflight during development\nawait connection.sendRawTransaction(serializedTx, {\n  skipPreflight: false, // default\n});`,
    relatedTerms: ['tx-simulation', 'transaction'],
  },
  {
    id: 'partial-signing',
    term: 'Partial Signing Transactions',
    category: 'Transactions',
    definition: 'Signing a transaction with only some of the required signers, then passing it to others for additional signatures. Essential for multisig flows and co-signed transactions where signers are on different machines.',
    whenToUse: 'When multiple parties need to sign: server + client co-signing, multisig approvals, or marketplace transactions where buyer and seller both sign.',
    example: `// Server partially signs\ntx.partialSign(serverKeypair);\nconst serialized = tx.serialize({ requireAllSignatures: false });\n// Send to client for final signature\n// Client deserializes, signs, and submits`,
    relatedTerms: ['signer', 'multisig', 'durable-nonce'],
  },
  {
    id: 'offline-signing',
    term: 'Offline Transaction Signing',
    category: 'Transactions',
    definition: 'Constructing and signing transactions on an air-gapped device. Requires durable nonces (since normal blockhashes expire in ~60s). The signed transaction is later transferred to an online machine for submission.',
    whenToUse: 'For maximum security of high-value operations. Cold wallet transactions, hardware wallet flows, or environments without internet access.',
    example: `// On offline machine: build tx with durable nonce\nconst tx = new Transaction();\ntx.add(SystemProgram.nonceAdvance({ ... }));\ntx.add(transferInstruction);\ntx.recentBlockhash = nonceAccountData.nonce; // Use nonce instead of blockhash\ntx.sign(offlineKeypair);\n// Transfer serialized tx to online machine`,
    relatedTerms: ['durable-nonce', 'partial-signing'],
  },
  {
    id: 'tx-landing-optimization',
    term: 'Transaction Landing Optimization',
    category: 'Transactions',
    definition: 'Techniques to increase the probability of a transaction being included in a block: priority fees, staked RPC connections, Jito bundles, multiple RPC submission, and proper compute unit estimation.',
    whenToUse: 'When transactions are failing to land during congestion. Use dynamic priority fees, submit to multiple RPCs, and set accurate compute limits.',
    example: `// Optimized transaction submission\nconst recentFees = await connection.getRecentPrioritizationFees();\nconst medianFee = calculateMedian(recentFees);\ntx.add(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: medianFee }));\ntx.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 200_000 }));`,
    relatedTerms: ['priority-fees', 'jito-bundles', 'compute-units'],
  },
  {
    id: 'tx-confirmation-ux',
    term: 'Transaction Confirmation UX Design',
    category: 'Transactions',
    definition: 'UI patterns for handling Solana\'s asynchronous confirmation flow. Show optimistic updates at "processed", confirm at "confirmed", and finalize at "finalized". Handle dropped transactions gracefully.',
    whenToUse: 'When building user-facing dApps. Show a pending state immediately, poll for confirmation, and implement retry logic for dropped transactions.',
    example: `// Confirmation with timeout\nconst sig = await connection.sendTransaction(tx);\nconst confirmation = await connection.confirmTransaction({\n  signature: sig,\n  blockhash: latestBlockhash.blockhash,\n  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,\n}, 'confirmed');\nif (confirmation.value.err) handleError();`,
    relatedTerms: ['commitment-levels', 'transaction'],
  },
  {
    id: 'failed-tx-debugging',
    term: 'Failed Transaction Debugging Workflow',
    category: 'Transactions',
    definition: 'A systematic approach to diagnosing transaction failures: check simulation logs, decode custom program errors, verify account states, check compute usage, and inspect instruction data. Solana Explorer shows detailed logs.',
    whenToUse: 'When transactions fail with opaque errors. Simulate first, read program logs, decode error codes from the IDL, and check if accounts are in the expected state.',
    example: `// Decode failed transaction\nconst txDetail = await connection.getTransaction(signature, {\n  maxSupportedTransactionVersion: 0,\n});\nconsole.log('Logs:', txDetail?.meta?.logMessages);\nconsole.log('Error:', txDetail?.meta?.err);\n// Check compute consumed vs budget\nconsole.log('CU used:', txDetail?.meta?.computeUnitsConsumed);`,
    relatedTerms: ['tx-simulation', 'program-logs-debugging', 'compute-units'],
  },
  {
    id: 'instruction-replay-safety',
    term: 'Instruction Replay Safety',
    category: 'Transactions',
    definition: 'Designing instructions so that re-executing them doesn\'t cause unintended side effects. Solana doesn\'t inherently prevent replay — your program must guard against double-processing using flags, nonces, or state checks.',
    whenToUse: 'For financial operations (claims, airdrops, one-time actions). Use a "claimed" flag in account state or derive unique PDAs per action to prevent double-execution.',
    example: `#[account]\npub struct ClaimReceipt {\n  pub claimed: bool,\n}\n// In instruction handler:\nrequire!(!receipt.claimed, MyError::AlreadyClaimed);\nreceipt.claimed = true;`,
    relatedTerms: ['idempotent-instruction-design', 'replay-attack-prevention'],
  },
  {
    id: 'priority-fee-auctions',
    term: 'Priority Fee Auctions',
    category: 'Transactions',
    definition: 'The competitive market for block inclusion via priority fees. During congestion, transactions bid against each other for limited block space. Higher fees = higher priority. Similar to EIP-1559 but per-account.',
    whenToUse: 'For time-sensitive operations during congestion. Monitor recent fees and bid competitively. Over-bidding wastes SOL; under-bidding risks transaction drops.',
    example: `// Fetch recent priority fees for specific accounts\nconst fees = await connection.getRecentPrioritizationFees({\n  lockedWritableAccounts: [poolAddress],\n});\nconst p75 = fees.sort((a,b) => a.prioritizationFee - b.prioritizationFee)\n  [Math.floor(fees.length * 0.75)]?.prioritizationFee ?? 1000;`,
    relatedTerms: ['priority-fees', 'tx-landing-optimization', 'mev'],
  },

  // ═══════════════════════════════════════════════════
  // CONSENSUS — 8 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'proof-of-history',
    term: 'Proof of History',
    abbreviation: 'PoH',
    category: 'Consensus',
    definition: 'A cryptographic clock that proves time has passed between events using sequential SHA-256 hashes. PoH allows validators to agree on time ordering without communication, enabling Solana\'s high throughput.',
    whenToUse: 'Understanding Solana\'s architecture. PoH is not a consensus mechanism itself — it\'s a clock that makes consensus faster by providing a verifiable ordering of events.',
    example: `// PoH chain: each hash includes the previous\n// hash_n = SHA256(hash_n-1)\n// Events are interleaved into the hash chain\n// Verifiers can check the chain in parallel`,
    relatedTerms: ['slot', 'leader-schedule', 'validator'],
  },
  {
    id: 'leader-schedule',
    term: 'Leader Schedule & Block Production',
    category: 'Consensus',
    definition: 'A deterministic rotation schedule assigning validators as "leaders" for specific slots. The leader for a slot receives transactions, orders them using PoH, and produces the block. The schedule is known 2 epochs in advance.',
    whenToUse: 'For understanding block production timing. Useful for MEV strategies and transaction landing — sending transactions directly to the current/next leader\'s TPU port can improve landing rates.',
    example: `// Check leader schedule\nconst schedule = await connection.getLeaderSchedule();\n// Returns: { validatorPubkey: [slot1, slot2, ...] }\n\n// Get current slot leader\nconst leader = await connection.getSlotLeader();`,
    relatedTerms: ['proof-of-history', 'slot', 'validator', 'turbine'],
  },
  {
    id: 'turbine',
    term: 'Turbine Block Propagation',
    category: 'Consensus',
    definition: 'Solana\'s block propagation protocol inspired by BitTorrent. Blocks are shredded into small packets and propagated through a tree structure of validators, so each node only forwards a fraction of the data.',
    whenToUse: 'Understanding how Solana achieves fast finality. Turbine ensures blocks reach all validators quickly without requiring the leader to send the full block to every node.',
    example: `// Turbine flow:\n// 1. Leader shreds block into ~1280-byte packets\n// 2. Sends shreds to "neighborhood" validators\n// 3. Each neighborhood forwards to the next layer\n// 4. All validators reconstruct the block\n// Result: O(log n) propagation time`,
    relatedTerms: ['leader-schedule', 'validator', 'gulf-stream'],
  },
  {
    id: 'gulf-stream',
    term: 'Gulf Stream Transaction Forwarding',
    category: 'Consensus',
    definition: 'Solana\'s mempool-less transaction forwarding protocol. Instead of a global mempool, clients send transactions directly to the current and next leaders. This reduces confirmation times and memory requirements.',
    whenToUse: 'Understanding why Solana doesn\'t have a traditional mempool. Transactions are forwarded to upcoming leaders, enabling sub-second confirmation.',
    example: `// Gulf Stream flow:\n// 1. Client submits tx to RPC node\n// 2. RPC forwards to current leader via QUIC\n// 3. Also forwards to next few leaders\n// 4. Leader includes tx in their block\n// No mempool = no mempool-based MEV`,
    relatedTerms: ['leader-schedule', 'quic-networking', 'turbine'],
  },
  {
    id: 'quic-networking',
    term: 'QUIC Networking in Solana',
    category: 'Consensus',
    definition: 'Solana uses the QUIC protocol (replacing UDP) for transaction ingestion. QUIC provides connection-level authentication, flow control, and rate limiting, helping prevent spam and DDoS attacks on validators.',
    whenToUse: 'Understanding Solana\'s networking layer. Staked connections get higher throughput limits via QUIC, which is why staked RPCs land transactions more reliably.',
    example: `// QUIC benefits for Solana:\n// - Staked connections get priority bandwidth\n// - Per-connection rate limiting prevents spam\n// - TLS encryption for transaction data\n// - Better congestion control than raw UDP`,
    relatedTerms: ['gulf-stream', 'tx-landing-optimization', 'validator'],
  },
  {
    id: 'replay-stage',
    term: 'Replay Stage & Fork Choice',
    category: 'Consensus',
    definition: 'The validator component that re-executes transactions from received blocks to verify correctness. Fork choice (Tower BFT) determines which fork of the chain to follow based on stake-weighted votes.',
    whenToUse: 'Understanding Solana internals. Forks are common and resolved quickly via Tower BFT. Most developers don\'t interact with this directly but should understand why "processed" confirmations can be rolled back.',
    example: `// Tower BFT fork choice:\n// 1. Validators vote on blocks they\'ve verified\n// 2. Votes have "lockout" periods (exponentially increasing)\n// 3. Fork with most stake-weighted votes wins\n// 4. Minority forks are abandoned`,
    relatedTerms: ['commitment-levels', 'forks-rollback', 'validator'],
  },
  {
    id: 'commitment-levels',
    term: 'Commitment Levels',
    category: 'Consensus',
    definition: 'Three tiers of transaction finality: "processed" (executed by leader, may be rolled back), "confirmed" (voted on by 66%+ stake, very unlikely to roll back), "finalized" (31+ blocks deep, irreversible).',
    whenToUse: 'Choose based on your use case. Use "confirmed" for most dApp UIs. Use "finalized" for irreversible actions (withdrawals, bridges). Use "processed" for lowest latency.',
    example: `// Specify commitment level\nconst balance = await connection.getBalance(pubkey, 'confirmed');\nconst slot = await connection.getSlot('finalized');\n\n// Connection default commitment\nconst conn = new Connection(url, 'confirmed');`,
    relatedTerms: ['replay-stage', 'slot', 'transaction'],
  },
  {
    id: 'forks-rollback',
    term: 'Forks & Rollback Handling',
    category: 'Consensus',
    definition: 'Temporary chain forks occur when multiple validators produce blocks for the same slot. Tower BFT resolves forks by stake-weighted voting. Transactions on abandoned forks are rolled back — they must be re-submitted.',
    whenToUse: 'When building reliable systems. Don\'t treat "processed" as final. Implement retry logic for dropped transactions. Use "confirmed" commitment for user-facing confirmations.',
    example: `// Handle potential rollbacks\nasync function sendAndConfirm(tx: Transaction) {\n  const sig = await connection.sendTransaction(tx);\n  const result = await connection.confirmTransaction(sig, 'confirmed');\n  if (result.value.err) {\n    // Transaction was included but failed\n    throw new Error('Transaction failed');\n  }\n  return sig; // Safe to show user\n}`,
    relatedTerms: ['commitment-levels', 'replay-stage', 'tx-confirmation-ux'],
  },

  // ═══════════════════════════════════════════════════
  // INFRASTRUCTURE — 8 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'concurrent-merkle-trees',
    term: 'Concurrent Merkle Trees',
    category: 'Infrastructure',
    definition: 'An optimized Merkle tree that supports multiple concurrent updates in the same block by maintaining a changelog buffer. Standard Merkle trees require sequential updates; concurrent trees allow parallel leaf modifications.',
    whenToUse: 'When using state compression at scale. The maxBufferSize parameter determines how many concurrent updates a tree can handle per slot. Higher buffer = more throughput but more rent.',
    example: `// Create concurrent Merkle tree\nconst tree = await createTree(umi, {\n  merkleTree,\n  maxDepth: 20,        // 1M+ leaves\n  maxBufferSize: 256,  // 256 concurrent updates per slot\n});`,
    relatedTerms: ['merkle-tree', 'state-compression', 'compressed-nft'],
  },
  {
    id: 'indexer-architecture',
    term: 'Indexer Architecture',
    category: 'Infrastructure',
    definition: 'Off-chain services that parse Solana transactions, decode program events, and store structured data in a queryable database. Essential for building responsive UIs since on-chain data queries are limited.',
    whenToUse: 'When your dApp needs to display historical data, search across accounts, or aggregate metrics. Use Helius, Triton, or custom Geyser plugin indexers.',
    example: `// Helius DAS API — indexes compressed NFTs, tokens, etc.\nconst assets = await helius.rpc.getAssetsByOwner({\n  ownerAddress: walletAddress,\n  page: 1,\n  limit: 100,\n});\n// Custom indexer: subscribe to program logs via Geyser`,
    relatedTerms: ['event-indexing-logs', 'rpc', 'websocket'],
  },
  {
    id: 'event-indexing-logs',
    term: 'Event Indexing from Logs',
    category: 'Infrastructure',
    definition: 'Extracting structured data from Solana program logs. Anchor programs emit events via `emit!()` which appear as base64-encoded data in transaction logs. Indexers decode these to build queryable databases.',
    whenToUse: 'When you need to track program activity off-chain. Emit events for state changes (trades, mints, transfers) and index them for dashboards and analytics.',
    example: `// Emit event in Anchor program\n#[event]\npub struct TradeExecuted {\n  pub user: Pubkey,\n  pub amount: u64,\n  pub price: u64,\n}\nemit!(TradeExecuted { user: ctx.accounts.user.key(), amount, price });\n// Appears in logs as: "Program data: <base64>"`,
    relatedTerms: ['indexer-architecture', 'anchor-events-vs-logs'],
  },
  {
    id: 'rpc-rate-limiting',
    term: 'RPC Rate Limiting Strategies',
    category: 'Infrastructure',
    definition: 'Techniques to handle RPC endpoint rate limits: request batching, connection pooling, caching responses, using WebSocket subscriptions instead of polling, and distributing across multiple RPC providers.',
    whenToUse: 'When hitting 429 (Too Many Requests) errors. Public RPCs are heavily rate-limited. Production apps need paid RPC providers and smart request management.',
    example: `// Rate limiting strategies:\n// 1. Cache getAccountInfo responses\nconst cache = new Map<string, { data: any; expiry: number }>();\n// 2. Batch multiple getMultipleAccounts\nconst accounts = await connection.getMultipleAccountsInfo(pubkeys);\n// 3. Use WebSocket instead of polling\nconnection.onAccountChange(pubkey, callback);`,
    relatedTerms: ['rpc', 'rpc-consistency', 'websocket'],
  },
  {
    id: 'rpc-consistency',
    term: 'RPC Consistency Guarantees',
    category: 'Infrastructure',
    definition: 'Different RPC nodes may return slightly different views of the chain depending on their sync status and commitment level. There\'s no guarantee two RPC calls hit the same node or return data from the same slot.',
    whenToUse: 'When debugging "stale data" issues. Use `minContextSlot` to ensure reads are at least as recent as a known slot. Specify commitment levels explicitly.',
    example: `// Ensure read is at least as recent as slot X\nconst balance = await connection.getBalance(pubkey, {\n  commitment: 'confirmed',\n  minContextSlot: knownSlot,\n});\n// After sending tx, wait before reading:\nawait connection.confirmTransaction(sig, 'confirmed');\nconst updated = await connection.getAccountInfo(pubkey); // Now consistent`,
    relatedTerms: ['commitment-levels', 'rpc', 'rpc-rate-limiting'],
  },
  {
    id: 'devnet-mainnet-differences',
    term: 'Devnet vs Mainnet Behavioral Differences',
    category: 'Infrastructure',
    definition: 'Devnet and mainnet differ in ways beyond just "test vs real money": different validators, different congestion patterns, different RPC rate limits, occasional devnet resets, and different program deployments.',
    whenToUse: 'Before deploying to mainnet. Test with realistic conditions: devnet has free airdrops and less congestion, which can mask issues that appear on mainnet.',
    example: `// Key differences to watch:\n// 1. Devnet airdrops SOL freely; mainnet requires real SOL\n// 2. Devnet has fewer validators = less realistic fork behavior\n// 3. Devnet may reset (all state wiped)\n// 4. Programs exist at different addresses\n// 5. Priority fees behave differently under load`,
    relatedTerms: ['devnet', 'mainnet', 'rpc'],
  },
  {
    id: 'sysvars',
    term: 'Sysvars',
    category: 'Infrastructure',
    definition: 'Special read-only accounts providing cluster state: Clock (current time/slot), Rent (rent parameters), Instructions (current transaction\'s instructions), SlotHashes (recent slot hashes), and more.',
    whenToUse: 'When your program needs cluster state. Clock sysvar for timestamps, Rent for minimum balance calculations, Instructions sysvar for introspection of the current transaction.',
    example: `// Access sysvars in Anchor\nuse anchor_lang::prelude::*;\n\n#[derive(Accounts)]\npub struct MyInstruction<'info> {\n  pub clock: Sysvar<'info, Clock>,\n}\n// Usage: let now = ctx.accounts.clock.unix_timestamp;`,
    relatedTerms: ['slot', 'rent', 'epoch'],
  },
  {
    id: 'sealevel-runtime',
    term: 'Sealevel Runtime Scheduling',
    category: 'Infrastructure',
    definition: 'Solana\'s parallel transaction execution engine. Sealevel analyzes each transaction\'s account access list to identify non-overlapping transactions and runs them simultaneously across CPU cores.',
    whenToUse: 'When optimizing program design for throughput. Structure state as per-user PDAs rather than global accounts to maximize parallelism under Sealevel.',
    example: `// Sealevel parallelism:\n// Tx A writes to [Account 1, Account 2]\n// Tx B writes to [Account 3, Account 4]\n// → Run in parallel (no overlap)\n//\n// Tx C writes to [Account 1, Account 3]\n// → Must serialize with both A and B`,
    relatedTerms: ['account-locking', 'writable-readonly-accounts', 'validator'],
  },

  // ═══════════════════════════════════════════════════
  // DEVELOPMENT — 18 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'system-program',
    term: 'System Program Responsibilities',
    category: 'Development',
    definition: 'The built-in program (address: 11111111111111111111111111111111) responsible for creating accounts, transferring SOL, allocating space, and assigning account ownership to other programs.',
    whenToUse: 'Whenever you create accounts or transfer SOL. It\'s passed as an account in nearly every transaction. Anchor includes it automatically when using `init`.',
    example: `import { SystemProgram } from '@solana/web3.js';\n\nconst createAccountIx = SystemProgram.createAccount({\n  fromPubkey: payer.publicKey,\n  newAccountPubkey: newAccount.publicKey,\n  lamports: rentExemptAmount,\n  space: dataSize,\n  programId: ownerProgramId,\n});`,
    relatedTerms: ['account', 'rent', 'lamports'],
  },
  {
    id: 'upgradeable-loader',
    term: 'Upgradeable Program Loader Internals',
    category: 'Development',
    definition: 'The BPF Upgradeable Loader manages program deployment and upgrades. Each program has three accounts: the program account (executable stub), the programdata account (actual bytecode), and a buffer account (used during upgrades).',
    whenToUse: 'When understanding program deployment, checking if a program is upgradeable, or managing upgrade authority transfers.',
    example: `# Check program details\nsolana program show <PROGRAM_ID>\n# Output shows:\n# - Program Id\n# - Owner: BPFLoaderUpgradeab1e11111111111111111111111\n# - ProgramData Address\n# - Authority (upgrade authority)\n# - Last Deployed Slot\n# - Data Length`,
    relatedTerms: ['upgradeable-buffer', 'program-authority', 'program-deployment-lifecycle'],
  },
  {
    id: 'borsh-serialization',
    term: 'Borsh Serialization',
    category: 'Development',
    definition: 'Binary Object Representation Serializer for Hashing — a deterministic, schema-based binary serialization format used by Solana programs. More efficient than JSON; produces consistent byte output for the same input.',
    whenToUse: 'When building raw (non-Anchor) Solana programs or when you need to manually serialize/deserialize instruction data. Anchor uses Borsh under the hood.',
    example: `// Borsh schema for instruction data\nimport { serialize, deserialize } from 'borsh';\n\nclass TransferArgs {\n  amount: number;\n  constructor(fields: { amount: number }) {\n    this.amount = fields.amount;\n  }\n}\nconst schema = new Map([[TransferArgs, { kind: 'struct', fields: [['amount', 'u64']] }]]);`,
    relatedTerms: ['discriminator', 'idl', 'anchor'],
  },
  {
    id: 'anchor-validation-pipeline',
    term: 'Anchor Account Validation Pipeline',
    category: 'Development',
    definition: 'Anchor\'s automatic account validation flow: deserialize → check discriminator → verify ownership → check constraints (has_one, seeds, mut, signer) → pass validated accounts to handler. All before your business logic runs.',
    whenToUse: 'Understanding how Anchor\'s #[derive(Accounts)] works. Most "constraint violated" errors come from this pipeline. Add custom constraints with `constraint = ...`.',
    example: `#[derive(Accounts)]\npub struct UpdateScore<'info> {\n  #[account(\n    mut,                                    // Must be writable\n    seeds = [b"game", player.key().as_ref()], // Verify PDA\n    bump,                                    // Check bump\n    has_one = authority,                     // game.authority == authority.key()\n  )]\n  pub game: Account<'info, GameState>,\n  pub authority: Signer<'info>,             // Must sign\n}`,
    relatedTerms: ['anchor', 'discriminator', 'anchor-constraint-macros'],
  },
  {
    id: 'anchor-constraint-macros',
    term: 'Anchor Constraint Macros',
    category: 'Development',
    definition: 'Declarative validation attributes in Anchor\'s #[account(...)] macro: mut, signer, init, seeds/bump, has_one, constraint, close, realloc, and more. They generate validation code at compile time.',
    whenToUse: 'When defining account structs in Anchor. Constraints prevent common security bugs by declaratively specifying access rules.',
    example: `#[account(\n  init,                               // Create account\n  payer = payer,                      // Who pays rent\n  space = 8 + 32 + 8,               // Account size\n  seeds = [b"vault", user.key().as_ref()],\n  bump,\n  constraint = amount > 0 @ MyError::InvalidAmount,\n)]\npub vault: Account<'info, Vault>,`,
    relatedTerms: ['anchor-validation-pipeline', 'anchor', 'space'],
  },
  {
    id: 'anchor-events-vs-logs',
    term: 'Anchor Events vs Logs',
    category: 'Development',
    definition: 'Anchor events (emit!) produce structured, typed log entries that can be parsed by clients. Regular msg!() logs are freeform strings. Events are base64-encoded with a discriminator; logs are plain text.',
    whenToUse: 'Use events for data indexers need to parse (trades, state changes). Use msg!() for debugging during development. Events have an 8-byte overhead for the discriminator.',
    example: `// Structured event (parseable by indexers)\n#[event]\npub struct SwapExecuted {\n  pub user: Pubkey,\n  pub in_amount: u64,\n  pub out_amount: u64,\n}\nemit!(SwapExecuted { user, in_amount, out_amount });\n\n// Debug log (not structured)\nmsg!("Swap: {} -> {}", in_amount, out_amount);`,
    relatedTerms: ['event-indexing-logs', 'anchor', 'program-logs-debugging'],
  },
  {
    id: 'program-logs-debugging',
    term: 'Program Logs & Debugging Strategy',
    category: 'Development',
    definition: 'Solana programs output logs via msg!() macro. Logs appear in transaction details and can be read via RPC. Use logs to trace execution flow, but be mindful — logging consumes compute units.',
    whenToUse: 'During development and debugging. Remove verbose logging before mainnet deployment to save compute units. Use structured events instead for production telemetry.',
    example: `// In Rust program\nmsg!("Processing transfer: {} lamports from {} to {}", amount, from, to);\n\n// Read logs from client\nconst tx = await connection.getTransaction(sig, { maxSupportedTransactionVersion: 0 });\nconsole.log(tx?.meta?.logMessages);`,
    relatedTerms: ['anchor-events-vs-logs', 'compute-units', 'failed-tx-debugging'],
  },
  {
    id: 'litesvm-testing',
    term: 'LiteSVM vs Local Validator Testing',
    category: 'Development',
    definition: 'LiteSVM is a lightweight, in-process Solana VM for fast unit testing (milliseconds per test). The local validator (solana-test-validator) is a full node for integration testing (seconds per test). Use both.',
    whenToUse: 'Use LiteSVM for fast iteration on program logic. Use the local validator for integration tests that need real RPC behavior, multiple programs, or account state loading.',
    example: `// LiteSVM (Rust) — fast unit tests\n#[test]\nfn test_transfer() {\n  let mut svm = LiteSVM::new();\n  svm.airdrop(&user, 1_000_000_000).unwrap();\n  let result = svm.send_transaction(tx);\n  assert!(result.is_ok());\n}\n// Local validator — integration tests\n// solana-test-validator --bpf-program <ID> <SO_FILE>`,
    relatedTerms: ['test-validator-architecture', 'devnet'],
  },
  {
    id: 'test-validator-architecture',
    term: 'Test Validator Architecture',
    category: 'Development',
    definition: 'solana-test-validator runs a single-node Solana cluster locally. It can clone accounts and programs from mainnet/devnet, supports instant confirmation, and provides a full RPC interface for integration testing.',
    whenToUse: 'For integration tests needing real RPC behavior. Clone mainnet accounts with `--clone` or programs with `--bpf-program`. Reset state between test runs.',
    example: `# Start with cloned mainnet state\nsolana-test-validator \\\n  --bpf-program <PROGRAM_ID> ./target/deploy/my_program.so \\\n  --clone <ACCOUNT_TO_CLONE> \\\n  --url mainnet-beta \\\n  --reset`,
    relatedTerms: ['litesvm-testing', 'devnet', 'rpc'],
  },
  {
    id: 'bpf-execution-model',
    term: 'BPF Execution Model',
    category: 'Development',
    definition: 'Solana programs compile to Berkeley Packet Filter (BPF/SBF) bytecode and run in a sandboxed VM. The VM enforces compute limits, stack depth (64 frames), heap size (32KB), and prevents syscalls outside the allowed set.',
    whenToUse: 'Understanding program constraints. If you hit stack overflow or heap allocation errors, you need to understand the BPF execution model to optimize your code.',
    example: `// BPF constraints:\n// - Stack frame: 4KB per frame, 64 frames max\n// - Heap: 32KB (use solana_program::entrypoint::HEAP_LENGTH)\n// - No dynamic dispatch (no dyn Trait)\n// - No std library (use solana_program)\n// - Compute budget: 200K-1.4M CU per transaction`,
    relatedTerms: ['llvm-sbf-pipeline', 'stack-frame-limits', 'heap-allocation-constraints'],
  },
  {
    id: 'llvm-sbf-pipeline',
    term: 'LLVM → SBF Compilation Pipeline',
    category: 'Development',
    definition: 'Solana programs are compiled from Rust → LLVM IR → SBF (Solana Bytecode Format) bytecode. The solana-platform-tools SDK provides the custom LLVM backend. SBF is an evolution of eBPF optimized for Solana.',
    whenToUse: 'When debugging compilation issues or optimizing program size. Understanding the pipeline helps diagnose "BPF program failed" errors and optimize binary size.',
    example: `# Compilation pipeline:\n# 1. Rust source → LLVM IR (rustc)\n# 2. LLVM IR → SBF object (llc with SBF backend)\n# 3. SBF object → .so shared library (lld)\n# Build command:\ncargo build-sbf\n# Output: target/deploy/my_program.so`,
    relatedTerms: ['bpf-execution-model', 'program-size-optimization'],
  },
  {
    id: 'program-deployment-lifecycle',
    term: 'Program Deployment Lifecycle',
    category: 'Development',
    definition: 'The stages of deploying a Solana program: compile to SBF → write binary to buffer account → create program account (first deploy) or upgrade (subsequent deploys) → verify → optionally renounce upgrade authority.',
    whenToUse: 'When deploying programs to devnet or mainnet. Understand each stage to debug deployment failures, manage upgrade authority, and recover from failed deployments.',
    example: `# Full deployment lifecycle:\ncargo build-sbf                              # 1. Compile\nsolana program deploy target/deploy/prog.so  # 2. Deploy (creates buffer + program)\nsolana program show <PROGRAM_ID>             # 3. Verify\n# Optional: make immutable\nsolana program set-upgrade-authority <ID> --final`,
    relatedTerms: ['upgradeable-loader', 'upgradeable-buffer', 'program-authority'],
  },
  {
    id: 'compute-profiling',
    term: 'Compute Profiling Techniques',
    category: 'Development',
    definition: 'Methods to measure and optimize compute unit consumption: simulation with detailed logs, sol_log_compute_units!() macro for per-section measurement, and comparing CU usage across implementations.',
    whenToUse: 'When optimizing program compute usage. Lower CU = lower priority fees. Profile before and after optimizations to verify improvements.',
    example: `// In Rust program: log CU at checkpoints\nsolana_program::log::sol_log_compute_units();\n// ... expensive operation ...\nsolana_program::log::sol_log_compute_units();\n// Diff in logs shows CU consumed by that section\n\n// From client: check total CU\nconst sim = await connection.simulateTransaction(tx);\nconsole.log('CU consumed:', sim.value.unitsConsumed);`,
    relatedTerms: ['compute-units', 'program-size-optimization'],
  },
  {
    id: 'program-size-optimization',
    term: 'Program Size Optimization',
    category: 'Development',
    definition: 'Techniques to reduce compiled program binary size: LTO (Link-Time Optimization), opt-level = "z", removing unused dependencies, feature flags, and using zero-copy instead of Borsh for large accounts.',
    whenToUse: 'When approaching the 10MB program size limit or to reduce deployment costs (deployment cost is proportional to size). Anchor programs average 200-500KB.',
    example: `# Cargo.toml optimizations\n[profile.release]\nopt-level = "z"       # Optimize for size\nlto = true            # Link-time optimization\ncodegen-units = 1     # Better optimization\nstrip = true          # Remove debug symbols\n# Result: 30-50% smaller binaries`,
    relatedTerms: ['bpf-execution-model', 'compute-profiling'],
  },
  {
    id: 'deterministic-execution',
    term: 'Deterministic Execution Constraints',
    category: 'Development',
    definition: 'Solana programs must be fully deterministic — given the same inputs, they must produce the same outputs. No randomness, no floating point, no system calls, no network access. This enables parallel validation.',
    whenToUse: 'When designing on-chain logic. Use integer arithmetic instead of floats. For randomness, use VRFs or hash-based solutions. For time, use the Clock sysvar.',
    example: `// ❌ Non-deterministic (won't compile for SBF)\nlet random = rand::random::<u64>();\nlet time = SystemTime::now();\n\n// ✅ Deterministic alternatives\nlet time = Clock::get()?.unix_timestamp;\nlet pseudo_random = hash(&[slot.to_le_bytes(), seed].concat());`,
    relatedTerms: ['bpf-execution-model', 'sysvars', 'deterministic-randomness'],
  },
  {
    id: 'serialization-cost-tradeoffs',
    term: 'Serialization Cost vs Compute Tradeoffs',
    category: 'Development',
    definition: 'Different serialization strategies have different compute costs. Borsh is safe but expensive for large accounts. Zero-copy is cheapest but restricts data types. Manual byte manipulation is fastest but error-prone.',
    whenToUse: 'When optimizing compute-heavy programs. For accounts <1KB, Borsh is fine. For larger accounts (order books, large arrays), use zero-copy to save thousands of CU.',
    example: `// Borsh: ~1000 CU for 1KB account\n#[account]\npub struct SmallState { pub data: [u8; 1024] }\n\n// Zero-copy: ~10 CU for same data\n#[account(zero_copy)]\n#[repr(C)]\npub struct LargeState { pub data: [u8; 10240] }\n// 100x CU savings for large accounts!`,
    relatedTerms: ['zero-copy-accounts', 'borsh-serialization', 'compute-units'],
  },
  {
    id: 'idempotent-instruction-design',
    term: 'Idempotent Instruction Design',
    category: 'Development',
    definition: 'Designing instructions so that executing them multiple times produces the same result as executing once. Critical for reliability since transactions may be retried by clients or validators.',
    whenToUse: 'For initialization and setup instructions. Use `init_if_needed` in Anchor or check if state already matches the desired value before modifying.',
    example: `// Idempotent: set value (safe to retry)\npub fn set_config(ctx: Context<SetConfig>, value: u64) -> Result<()> {\n  ctx.accounts.config.value = value; // Same result regardless of retries\n  Ok(())\n}\n\n// NOT idempotent: increment (unsafe to retry)\npub fn increment(ctx: Context<Inc>) -> Result<()> {\n  ctx.accounts.counter.count += 1; // Doubles on retry!\n  Ok(())\n}`,
    relatedTerms: ['instruction-replay-safety', 'atomic-transactions'],
  },
  {
    id: 'state-machine-on-chain',
    term: 'State Machine Modeling On-Chain',
    category: 'Development',
    definition: 'Modeling program logic as explicit state machines with defined states and transitions. Each instruction validates the current state and transitions to a new one. Prevents invalid state transitions.',
    whenToUse: 'For multi-step processes: auctions, escrows, games, order fulfillment. Define states as an enum and guard transitions in each instruction handler.',
    example: `#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]\npub enum AuctionState {\n  Created,\n  Active,\n  Ended,\n  Settled,\n}\n// In handler:\nrequire!(auction.state == AuctionState::Active, AuctionError::NotActive);\nauction.state = AuctionState::Ended;`,
    relatedTerms: ['idempotent-instruction-design', 'anchor'],
  },
  {
    id: 'optimistic-ui-finalized',
    term: 'Optimistic UI vs Finalized State',
    category: 'Development',
    definition: 'Showing UI updates immediately after transaction submission (optimistic) before waiting for on-chain confirmation (finalized). Improves perceived performance but requires handling rollbacks gracefully.',
    whenToUse: 'For responsive dApp UIs. Update the UI optimistically, show a "confirming" indicator, and reconcile if the transaction fails. Most users expect sub-second feedback.',
    example: `// Optimistic update pattern\nsetBalance(prev => prev - amount); // Immediate UI update\ntry {\n  const sig = await sendTransaction(tx);\n  await connection.confirmTransaction(sig, 'confirmed');\n  // Confirmed — UI already shows correct state\n} catch {\n  setBalance(prev => prev + amount); // Rollback on failure\n  toast.error('Transaction failed');\n}`,
    relatedTerms: ['commitment-levels', 'tx-confirmation-ux'],
  },
  {
    id: 'state-migration-strategies',
    term: 'State Migration Strategies',
    category: 'Development',
    definition: 'Techniques for upgrading on-chain account schemas: versioned accounts with lazy migration, separate migration instructions, account closure + recreation, or parallel new/old accounts during transition.',
    whenToUse: 'When upgrading a program that changes account structure. Plan migration before deploying — you can\'t change existing account layouts without an explicit migration step.',
    example: `// Versioned account pattern\n#[account]\npub struct ConfigV2 {\n  pub version: u8,        // 1 = old, 2 = new\n  pub authority: Pubkey,\n  pub new_field: u64,     // Added in v2\n}\n// Lazy migration: check version on each access\nif config.version == 1 {\n  config.new_field = default_value;\n  config.version = 2;\n}`,
    relatedTerms: ['backward-compatible-upgrades', 'program-deployment-lifecycle'],
  },
  {
    id: 'backward-compatible-upgrades',
    term: 'Backward-Compatible Account Upgrades',
    category: 'Development',
    definition: 'Adding new fields to existing accounts without breaking old data. Append-only changes (new fields at the end) with realloc can be backward-compatible. Changing field order or types requires full migration.',
    whenToUse: 'When adding features to an existing program. Only append new fields to the end of structs. Use realloc to expand space. Never reorder or remove existing fields.',
    example: `// V1: Original struct\n#[account]\npub struct Config {\n  pub authority: Pubkey,  // 32 bytes\n  pub fee_bps: u16,       // 2 bytes\n}\n\n// V2: Add field at end + realloc\n#[account]\npub struct Config {\n  pub authority: Pubkey,  // 32 bytes (unchanged)\n  pub fee_bps: u16,       // 2 bytes (unchanged)\n  pub max_amount: u64,    // 8 bytes (NEW — appended)\n}`,
    relatedTerms: ['state-migration-strategies', 'account-realloc'],
  },

  // ═══════════════════════════════════════════════════
  // SECURITY — 13 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'reentrancy-solana',
    term: 'Reentrancy in Solana',
    category: 'Security',
    definition: 'Unlike EVM, Solana programs cannot recursively call themselves via CPI (runtime prevents it). However, reentrancy-like bugs can occur when a CPI to another program calls back into your program through a different instruction.',
    whenToUse: 'When your program makes CPIs to untrusted programs. Apply checks-effects-interactions pattern: validate → update state → make CPI. Never trust external program behavior.',
    example: `// Safe pattern: update state BEFORE CPI\npub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n  let vault = &mut ctx.accounts.vault;\n  require!(vault.balance >= amount, Error::InsufficientFunds);\n  vault.balance -= amount;  // Update FIRST\n  // Then CPI to transfer\n  transfer_sol(ctx.accounts.vault_pda, ctx.accounts.user, amount)?;\n  Ok(())\n}`,
    relatedTerms: ['cpi', 'cpi-depth-limits'],
  },
  {
    id: 'upgradeable-program-risks',
    term: 'Upgradeable Program Security Risks',
    category: 'Security',
    definition: 'Upgradeable programs can be modified by the upgrade authority, introducing rug-pull risk. Users must trust the authority won\'t deploy malicious code. Mitigate with multisig authority, timelocks, or immutability.',
    whenToUse: 'When evaluating protocol security. Check if the upgrade authority is a multisig, has a timelock, or if the program is immutable. Immutable = maximum trust, zero upgradability.',
    example: `# Check if program is upgradeable\nsolana program show <PROGRAM_ID>\n# If Authority is "none" → immutable (safe but not patchable)\n# If Authority is a single key → rug risk!\n# If Authority is a multisig → acceptable for most protocols\n# Best: multisig + governance timelock`,
    relatedTerms: ['program-authority', 'multisig', 'upgradeable-loader'],
  },
  {
    id: 'replay-attack-prevention',
    term: 'Replay Attack Prevention',
    category: 'Security',
    definition: 'Preventing a valid transaction from being executed more than once. Solana\'s blockhash expiry provides basic replay protection (transactions expire in ~60s). For instruction-level replay, use nonces or state flags.',
    whenToUse: 'For one-time operations like token claims or airdrops. The blockhash prevents full transaction replay, but instruction-level replay needs your own guards.',
    example: `// Instruction-level replay prevention\n#[account]\npub struct ClaimState {\n  pub claimed: bool,\n  pub claim_amount: u64,\n}\n\npub fn claim(ctx: Context<Claim>) -> Result<()> {\n  require!(!ctx.accounts.claim_state.claimed, Error::AlreadyClaimed);\n  ctx.accounts.claim_state.claimed = true;\n  // ... transfer tokens ...\n  Ok(())\n}`,
    relatedTerms: ['instruction-replay-safety', 'blockhash', 'durable-nonce'],
  },
  {
    id: 'signature-verification-flow',
    term: 'Signature Verification Flow',
    category: 'Security',
    definition: 'The process of verifying Ed25519 signatures on Solana. The runtime verifies transaction signatures automatically. For verifying arbitrary signatures within a program, use the Ed25519 precompile program.',
    whenToUse: 'When your program needs to verify messages signed off-chain — e.g., oracle data, gasless transactions, or signed authorization messages.',
    example: `// Verify an Ed25519 signature in a program\n// Add Ed25519 signature verification instruction\nlet verify_ix = ed25519_program::new_ed25519_instruction(\n  &signer_pubkey,\n  &message,\n  &signature,\n);\n// Must be in same transaction as your instruction\n// Check via Instructions sysvar introspection`,
    relatedTerms: ['ed25519-program', 'signer'],
  },
  {
    id: 'ed25519-program',
    term: 'Ed25519 Program Usage',
    category: 'Security',
    definition: 'A native Solana program that verifies Ed25519 signatures. Used for verifying arbitrary signed messages within on-chain programs — not just transaction signatures. Costs ~2000 CU per verification.',
    whenToUse: 'For verifying off-chain signatures on-chain. Common in oracle systems, gasless relayers, and cross-chain bridges. The instruction must precede your program\'s instruction in the same transaction.',
    example: `import { Ed25519Program } from '@solana/web3.js';\n\nconst verifyIx = Ed25519Program.createInstructionWithPublicKey({\n  publicKey: signerPubkey.toBytes(),\n  message: Buffer.from('authorize:withdraw:1000'),\n  signature: signatureBytes,\n});\ntx.add(verifyIx, myProgramIx); // verify BEFORE your instruction`,
    relatedTerms: ['signature-verification-flow', 'secp256k1-program'],
  },
  {
    id: 'secp256k1-program',
    term: 'Secp256k1 Verification Program',
    category: 'Security',
    definition: 'A native Solana program that verifies secp256k1 (Ethereum-style) signatures. Enables cross-chain verification of Ethereum signatures on Solana, useful for bridges and multi-chain identity.',
    whenToUse: 'When verifying Ethereum wallet signatures on Solana — e.g., proving ownership of an Ethereum address, cross-chain messaging, or EVM-compatible authentication.',
    example: `import { Secp256k1Program } from '@solana/web3.js';\n\nconst verifyIx = Secp256k1Program.createInstructionWithEthAddress({\n  ethAddress: ethereumAddress,\n  message: messageBytes,\n  signature: ethSignatureBytes,\n  recoveryId,\n});\ntx.add(verifyIx, myProgramIx);`,
    relatedTerms: ['ed25519-program', 'signature-verification-flow'],
  },
  {
    id: 'compute-exhaustion-attacks',
    term: 'Compute Exhaustion Attacks',
    category: 'Security',
    definition: 'An attacker crafts inputs that maximize compute unit consumption, causing legitimate instructions to fail by exceeding the transaction\'s compute budget. Common with unbounded loops or recursive operations.',
    whenToUse: 'When designing instruction handlers. Always bound loops, limit recursion depth, and validate input sizes. Use require!() checks early to fail fast on invalid inputs.',
    example: `// ❌ Vulnerable: unbounded loop\nfor item in items.iter() {\n  process(item)?;  // Attacker sends 10000 items → CU exhaustion\n}\n\n// ✅ Safe: bound the loop\nrequire!(items.len() <= MAX_ITEMS, Error::TooManyItems);\nfor item in items.iter().take(MAX_ITEMS) {\n  process(item)?;\n}`,
    relatedTerms: ['compute-units', 'stack-frame-limits'],
  },
  {
    id: 'account-inflation-attacks',
    term: 'Account Inflation Attacks',
    category: 'Security',
    definition: 'An attacker creates many small accounts to bloat program state, increasing storage costs and slowing queries. If your program stores unbounded data per user, attackers can inflate costs.',
    whenToUse: 'When designing account structures. Limit the number of accounts users can create. Require rent deposits from users creating accounts. Use PDAs with bounded seed spaces.',
    example: `// ❌ Vulnerable: unlimited account creation\n// User can create millions of "note" PDAs\n\n// ✅ Safe: limit accounts per user\n#[account(\n  constraint = user_stats.note_count < MAX_NOTES @ Error::TooManyNotes,\n)]\npub user_stats: Account<'info, UserStats>,`,
    relatedTerms: ['rent', 'rent-draining-vectors', 'account'],
  },
  {
    id: 'rent-draining-vectors',
    term: 'Rent Draining Vectors',
    category: 'Security',
    definition: 'Attacks where an adversary drains lamports from accounts by exploiting the rent system. If an account drops below rent-exempt threshold, it may be garbage-collected. Guard against unauthorized lamport transfers.',
    whenToUse: 'When handling lamport transfers or account closure. Ensure only authorized users can withdraw lamports. Validate remaining balance stays above rent-exempt minimum.',
    example: `// Ensure account stays rent-exempt after withdrawal\nlet rent_exempt = Rent::get()?.minimum_balance(account.data_len());\nlet available = account.lamports() - rent_exempt;\nrequire!(amount <= available, Error::InsufficientFunds);`,
    relatedTerms: ['rent', 'account-inflation-attacks', 'lamports'],
  },
  {
    id: 'cpi-depth-limits',
    term: 'CPI Depth Limits',
    category: 'Security',
    definition: 'Solana limits CPI call depth to 4 levels (program A → B → C → D → E is the maximum chain). This prevents infinite recursion and limits the complexity of cross-program call chains.',
    whenToUse: 'When designing multi-program architectures. If program A calls B calls C calls D, you\'re at the limit. Flatten call chains where possible to avoid hitting the depth limit.',
    example: `// CPI depth limit: 4 levels\n// Program A (depth 0)\n//   → CPI to Program B (depth 1)\n//     → CPI to Program C (depth 2)\n//       → CPI to Program D (depth 3)\n//         → CPI to Program E (depth 4) ✅ Last allowed\n//           → CPI to Program F ❌ FAILS!`,
    relatedTerms: ['cpi', 'reentrancy-solana', 'stack-frame-limits'],
  },
  {
    id: 'stack-frame-limits',
    term: 'Stack Frame Limits',
    category: 'Security',
    definition: 'Each BPF stack frame is limited to 4KB. The total stack depth is 64 frames. Deep recursion or large stack-allocated variables will cause "access violation" or "stack overflow" errors at runtime.',
    whenToUse: 'When hitting stack overflow errors. Move large data to the heap with Box::new(), reduce recursion depth, or refactor into iterative algorithms.',
    example: `// ❌ Stack overflow: large struct on stack\nlet big_array = [0u8; 8192]; // 8KB > 4KB frame limit!\n\n// ✅ Use heap allocation\nlet big_array = Box::new([0u8; 8192]); // Allocated on 32KB heap\n\n// ✅ Or use zero-copy accounts instead of stack\n#[account(zero_copy)]\npub struct LargeData { pub data: [u8; 8192] }`,
    relatedTerms: ['bpf-execution-model', 'heap-allocation-constraints'],
  },
  {
    id: 'heap-allocation-constraints',
    term: 'Heap Allocation Constraints',
    category: 'Security',
    definition: 'Solana\'s BPF VM provides a 32KB heap using a bump allocator. Once allocated, memory cannot be freed within a single instruction. Exceeding the heap causes an out-of-memory error.',
    whenToUse: 'When processing large data on-chain. 32KB total for all heap allocations in one instruction. Use zero-copy accounts for large data instead of deserializing to heap.',
    example: `// Heap budget: 32KB total per instruction\n// Each Box, Vec, String uses heap\n\n// ❌ Will OOM: deserializing large account to heap\nlet data: Vec<Item> = borsh_deserialize(&account.data)?; // If > 32KB\n\n// ✅ Use zero-copy: no heap needed\n#[account(zero_copy)]\npub struct OrderBook { pub orders: [Order; 1000] } // Direct memory map`,
    relatedTerms: ['stack-frame-limits', 'bpf-execution-model', 'zero-copy-accounts'],
  },
  {
    id: 'deterministic-randomness',
    term: 'Deterministic Randomness Strategies',
    category: 'Security',
    definition: 'On-chain randomness is hard because programs must be deterministic. Options: VRF oracles (Switchboard), hash-based pseudo-randomness from slot hashes, or commit-reveal schemes. Never use slot number alone.',
    whenToUse: 'For games, lotteries, random selection. VRFs provide the strongest guarantees. Hash-based methods are cheaper but manipulable by validators. Commit-reveal works for two-party scenarios.',
    example: `// Pseudo-random from recent slothash (manipulable by validators!)\nlet recent_slothash = &ctx.accounts.recent_slothashes.data.borrow();\nlet seed = &recent_slothash[12..20];\nlet random = u64::from_le_bytes(seed.try_into().unwrap());\n\n// Better: use Switchboard VRF for verifiable randomness`,
    relatedTerms: ['on-chain-randomness', 'sysvars'],
  },

  // ═══════════════════════════════════════════════════
  // TOKENS — 3 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'mint-freeze-authority',
    term: 'Mint Authority vs Freeze Authority',
    category: 'Tokens',
    definition: 'Mint authority can create new tokens (increase supply). Freeze authority can freeze any token account, preventing transfers. Both can be set to null (renounced). Separate authorities enable different trust models.',
    whenToUse: 'When creating tokens. Renounce mint authority for fixed-supply tokens. Keep freeze authority for compliance tokens. Check authorities when evaluating token safety.',
    example: `import { createMint, setAuthority, AuthorityType } from '@solana/spl-token';\n\n// Create mint with both authorities\nconst mint = await createMint(conn, payer, mintAuthority, freezeAuthority, 9);\n\n// Renounce mint authority (no more minting)\nawait setAuthority(conn, payer, mint, mintAuthority, AuthorityType.MintTokens, null);`,
    relatedTerms: ['mint', 'spl-token', 'program-authority'],
  },
  {
    id: 'delegation-mechanics',
    term: 'Delegation Mechanics',
    category: 'Tokens',
    definition: 'SPL Token allows account owners to delegate a specific token amount to another address for spending. The delegate can transfer up to the approved amount. Commonly used for DEX approvals and escrow patterns.',
    whenToUse: 'When a program needs to transfer tokens on behalf of a user. The user approves (delegates) a certain amount, then the program can transfer up to that amount via CPI.',
    example: `import { approve } from '@solana/spl-token';\n\n// User delegates 100 tokens to the program PDA\nawait approve(\n  connection, payer,\n  userTokenAccount,\n  programPda,        // delegate\n  userWallet,        // owner\n  100_000_000,       // amount (with decimals)\n);`,
    relatedTerms: ['spl-token', 'associated-token-account', 'cpi'],
  },
  {
    id: 'metaplex-metadata',
    term: 'Metaplex Metadata Accounts',
    category: 'Tokens',
    definition: 'On-chain accounts (PDA of the Metadata program) that store token metadata: name, symbol, URI (pointing to off-chain JSON), creators, royalty basis points, and collection information.',
    whenToUse: 'When creating NFTs or fungible tokens with metadata. Metaplex Token Metadata is the de facto standard. URI points to JSON with image, description, and attributes.',
    example: `// Metadata PDA derivation\nconst [metadataPda] = PublicKey.findProgramAddressSync(\n  [Buffer.from('metadata'), METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n  METADATA_PROGRAM_ID\n);\n// Metadata JSON (at URI):\n// { "name": "Cool NFT", "image": "https://...", "attributes": [...] }`,
    relatedTerms: ['nft', 'mint', 'compressed-nft'],
  },

  // ═══════════════════════════════════════════════════
  // NFTs — 2 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'candy-machine',
    term: 'Candy Machine Architecture',
    category: 'NFTs',
    definition: 'Metaplex\'s NFT distribution program. Manages mint order, pricing, start dates, whitelist/allowlist, and payment. Acts as a vending machine — users pay and receive a randomly (or sequentially) selected NFT from the collection.',
    whenToUse: 'For NFT launches and drops. Candy Machine v3 supports guards (conditions like start time, token gating, mint limits) for customizable minting experiences.',
    example: `// Create Candy Machine with guards\nconst candyMachine = await create(umi, {\n  itemsAvailable: 10000,\n  guards: {\n    startDate: { date: dateTime('2024-01-01T00:00:00Z') },\n    solPayment: { lamports: sol(0.5), destination: treasury },\n    mintLimit: { id: 1, limit: 3 },  // Max 3 per wallet\n  },\n});`,
    relatedTerms: ['nft', 'metaplex-metadata', 'compressed-nft'],
  },
  {
    id: 'on-chain-randomness',
    term: 'On-Chain Randomness Limitations',
    category: 'NFTs',
    definition: 'True randomness is impossible on-chain because validators can preview and manipulate block data. SlotHash-based randomness is cheap but validator-manipulable. VRF oracles are secure but add latency and cost.',
    whenToUse: 'For fair NFT reveals, games, and lotteries. Use Switchboard VRF for high-stakes randomness. For low-stakes use cases, commit-reveal or slothash-based methods may suffice.',
    example: `// Commit-reveal scheme for fair randomness:\n// Step 1: User commits hash(secret) on-chain\n// Step 2: Wait N slots\n// Step 3: User reveals secret\n// Step 4: Random = hash(secret + slothash at commit slot)\n// Neither user nor validator can predict the outcome alone`,
    relatedTerms: ['deterministic-randomness', 'sysvars'],
  },

  // ═══════════════════════════════════════════════════
  // DeFi — 4 new entries
  // ═══════════════════════════════════════════════════
  {
    id: 'oracle-design-patterns',
    term: 'Oracle Design Patterns (Pyth/Switchboard)',
    category: 'DeFi',
    definition: 'Oracles bring off-chain data (prices, randomness, sports scores) on-chain. Pyth provides low-latency price feeds via pull-based model. Switchboard offers customizable data feeds and VRF randomness.',
    whenToUse: 'When your program needs real-world data. DeFi protocols need price oracles for liquidations, swaps, and lending. Always validate oracle data staleness and confidence intervals.',
    example: `// Read Pyth price feed\nuse pyth_solana_receiver_sdk::price_update::PriceUpdateV2;\n\nlet price_feed = &ctx.accounts.price_update;\nlet price = price_feed.get_price_no_older_than(\n  &Clock::get()?,\n  60,  // max age in seconds\n)?;\nlet sol_price_usd = price.price as f64 * 10f64.powi(price.exponent);`,
    relatedTerms: ['mev', 'tvl'],
  },
  {
    id: 'escrow-design-patterns',
    term: 'Escrow Design Patterns',
    category: 'DeFi',
    definition: 'Programs that hold assets in a PDA-owned account until conditions are met. Common patterns: token escrow (hold tokens until counterparty acts), time-locked escrow, and conditional escrow with oracle verification.',
    whenToUse: 'For trustless exchanges, marketplaces, and conditional payments. The PDA acts as a neutral third party that releases funds only when programmatic conditions are satisfied.',
    example: `#[account]\npub struct Escrow {\n  pub maker: Pubkey,\n  pub taker: Option<Pubkey>,\n  pub deposit_amount: u64,\n  pub expected_amount: u64,\n  pub deadline: i64,\n  pub state: EscrowState,\n}\n// Maker deposits → Taker fulfills → Program releases\n// If deadline passes → Maker can reclaim`,
    relatedTerms: ['pda', 'state-machine-on-chain', 'cpi'],
  },
  {
    id: 'jito-bundles',
    term: 'Jito Bundles & Block Engines',
    category: 'DeFi',
    definition: 'Jito bundles allow submitting multiple transactions that are guaranteed to execute sequentially and atomically (all-or-nothing). Block engines route bundles to validators running Jito\'s modified client. Users tip validators for inclusion.',
    whenToUse: 'For MEV strategies (arbitrage, liquidation), multi-transaction workflows requiring atomicity, and priority transaction landing during congestion.',
    example: `// Submit a Jito bundle\nconst bundle = [\n  tx1, // Frontrun: place order\n  tx2, // Target: user's swap\n  tx3, // Backrun: close position\n];\n// Tip transaction (required)\nbundle.push(tipTx); // Tip to Jito tip accounts\n// Submit via Jito block engine endpoint`,
    relatedTerms: ['mev', 'priority-fee-auctions', 'tx-landing-optimization'],
  },
  {
    id: 'wallet-adapter-lifecycle',
    term: 'Wallet Adapter Lifecycle',
    category: 'DeFi',
    definition: 'The @solana/wallet-adapter manages the connection flow: detect installed wallets → user selects wallet → connect → sign transactions → disconnect. Handles multiple wallet providers with a unified API.',
    whenToUse: 'For any Solana dApp that needs user wallet interaction. Use WalletProvider and ConnectionProvider at the app root. Access wallet state via useWallet() hook.',
    example: `import { useWallet } from '@solana/wallet-adapter-react';\n\nfunction MyComponent() {\n  const { publicKey, connected, signTransaction, disconnect } = useWallet();\n  if (!connected) return <WalletMultiButton />;\n  return <p>Connected: {publicKey?.toBase58()}</p>;\n}`,
    relatedTerms: ['signer', 'transaction'],
  },

  // ═══════════════════════════════════════════════════
  // GOVERNANCE — 1 new entry
  // ═══════════════════════════════════════════════════
  {
    id: 'time-locked-accounts',
    term: 'Time-Locked Accounts / Vesting Contracts',
    category: 'Governance',
    definition: 'On-chain programs that lock tokens until a specified time or condition. Used for token vesting (team/investor allocations), governance timelocks (delay before executing proposals), and staking lockups.',
    whenToUse: 'For token distribution with vesting schedules, adding delay to governance execution (safety measure), or any time-based token release mechanism.',
    example: `#[account]\npub struct VestingSchedule {\n  pub beneficiary: Pubkey,\n  pub total_amount: u64,\n  pub released_amount: u64,\n  pub start_time: i64,\n  pub cliff_duration: i64,  // e.g., 6 months\n  pub total_duration: i64,  // e.g., 24 months\n}\n// Claimable = total * (elapsed - cliff) / (duration - cliff)`,
    relatedTerms: ['governance', 'multisig', 'dao'],
  },

  // ═══════════════════════════════════════════════════
  // CONSENSUS — 1 additional entry
  // ═══════════════════════════════════════════════════
  {
    id: 'optimistic-concurrency',
    term: 'Optimistic Concurrency Model',
    category: 'Consensus',
    definition: 'Solana assumes transactions won\'t conflict and executes them in parallel. If two transactions write to the same account, only one succeeds (the other is retried or dropped). This optimistic approach maximizes throughput.',
    whenToUse: 'When designing high-throughput programs. Minimize shared writable accounts. If contention is expected (hot accounts), implement client-side retry logic.',
    example: `// Optimistic concurrency in practice:\n// 1. Two users submit txs writing to same account\n// 2. Both are scheduled optimistically in parallel\n// 3. One succeeds, one fails with "already processed"\n// 4. Failed tx must be retried with fresh blockhash\n\n// Client retry pattern:\nfor (let i = 0; i < 3; i++) {\n  try { await sendAndConfirm(tx); break; }\n  catch { tx.recentBlockhash = await getLatestBlockhash(); }\n}`,
    relatedTerms: ['sealevel-runtime', 'account-locking', 'forks-rollback'],
  },
];

export function getDictionaryByCategory(category: DictionaryCategory): DictionaryEntry[] {
  return dictionary.filter((e) => e.category === category);
}

export function searchDictionary(query: string): DictionaryEntry[] {
  const q = query.toLowerCase();
  return dictionary.filter(
    (e) =>
      e.term.toLowerCase().includes(q) ||
      (e.abbreviation && e.abbreviation.toLowerCase().includes(q)) ||
      e.definition.toLowerCase().includes(q) ||
      e.category.toLowerCase().includes(q)
  );
}

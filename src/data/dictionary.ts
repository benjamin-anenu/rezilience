export interface DictionaryEntry {
  id: string;
  term: string;
  abbreviation?: string;
  category: DictionaryCategory;
  definition: string;
  whenToUse: string;
  example: string;
  relatedTerms: string[];
}

export type DictionaryCategory =
  | 'Accounts'
  | 'Transactions'
  | 'DeFi'
  | 'NFTs'
  | 'Governance'
  | 'Infrastructure'
  | 'Security'
  | 'Tokens'
  | 'Consensus'
  | 'Development';

export const dictionaryCategories: DictionaryCategory[] = [
  'Accounts',
  'Transactions',
  'DeFi',
  'NFTs',
  'Governance',
  'Infrastructure',
  'Security',
  'Tokens',
  'Consensus',
  'Development',
];

export const dictionary: DictionaryEntry[] = [
  {
    id: 'pda',
    term: 'Program Derived Address',
    abbreviation: 'PDA',
    category: 'Accounts',
    definition: 'An account address deterministically derived from a program ID and a set of seeds. PDAs are not on the Ed25519 curve, meaning no private key exists for them — only the owning program can sign on their behalf.',
    whenToUse: 'When your program needs to own accounts or sign transactions without a private key. Common for escrow accounts, vaults, and protocol-owned state.',
    example: `const [pda, bump] = PublicKey.findProgramAddressSync(\n  [Buffer.from("vault"), userPubkey.toBuffer()],\n  programId\n);`,
    relatedTerms: ['seeds', 'bump-seed', 'cpi'],
  },
  {
    id: 'seeds',
    term: 'Seeds',
    category: 'Accounts',
    definition: 'Byte arrays used as inputs to derive a PDA. Seeds make each PDA unique and predictable — anyone who knows the seeds and program ID can re-derive the same address.',
    whenToUse: 'When deriving PDAs. Use meaningful seeds (e.g., user pubkey + "vault") so the address can be found without storing it.',
    example: `// Seeds: ["user-profile", wallet_address]\nlet seeds = &[b"user-profile", user.key().as_ref()];`,
    relatedTerms: ['pda', 'bump-seed'],
  },
  {
    id: 'bump-seed',
    term: 'Bump Seed',
    category: 'Accounts',
    definition: 'A single byte (0-255) appended to seeds to push a derived address off the Ed25519 curve, making it a valid PDA. The runtime tries bump values from 255 down to 0 until a valid PDA is found.',
    whenToUse: 'Always stored alongside a PDA so you don\'t recompute it. Anchor handles this automatically with the `bump` constraint.',
    example: `#[account(\n  seeds = [b"config"],\n  bump = config.bump,\n)]\npub config: Account<'info, Config>,`,
    relatedTerms: ['pda', 'seeds'],
  },
  {
    id: 'cpi',
    term: 'Cross-Program Invocation',
    abbreviation: 'CPI',
    category: 'Transactions',
    definition: 'A mechanism that allows one Solana program to call another program\'s instructions within a single transaction. The calling program can pass its signer privileges to the callee.',
    whenToUse: 'When your program needs to interact with another on-chain program — e.g., transferring SOL via the System Program or minting tokens via the Token Program.',
    example: `// CPI to transfer SOL\nanchor_lang::system_program::transfer(\n  CpiContext::new(system_program, Transfer {\n    from: sender.to_account_info(),\n    to: receiver.to_account_info(),\n  }),\n  amount,\n)?;`,
    relatedTerms: ['pda', 'instruction', 'signer'],
  },
  {
    id: 'lamports',
    term: 'Lamports',
    category: 'Tokens',
    definition: 'The smallest unit of SOL. 1 SOL = 1,000,000,000 (1 billion) lamports. Named after Leslie Lamport, a computer scientist known for distributed systems research.',
    whenToUse: 'All on-chain SOL amounts are expressed in lamports. Always convert when displaying to users: `balance / LAMPORTS_PER_SOL`.',
    example: `import { LAMPORTS_PER_SOL } from '@solana/web3.js';\nconst solBalance = lamports / LAMPORTS_PER_SOL;`,
    relatedTerms: ['sol', 'rent'],
  },
  {
    id: 'rent',
    term: 'Rent',
    category: 'Accounts',
    definition: 'A fee charged to keep accounts alive on Solana. Accounts must maintain a minimum SOL balance (rent-exempt threshold) proportional to their data size. If below this threshold, the account is garbage-collected.',
    whenToUse: 'When creating accounts, always fund them to be rent-exempt. Use `getMinimumBalanceForRentExemption()` to calculate the required lamports.',
    example: `const rentExempt = await connection.getMinimumBalanceForRentExemption(dataSize);\n// Fund the account with at least this amount`,
    relatedTerms: ['lamports', 'account', 'space'],
  },
  {
    id: 'account',
    term: 'Account',
    category: 'Accounts',
    definition: 'The fundamental storage unit on Solana. Everything is an account — wallets, programs, data. Each account has an owner (program), balance (lamports), data (byte array), and executable flag.',
    whenToUse: 'Understanding accounts is foundational. Wallets are accounts owned by the System Program. Program state is stored in accounts owned by your program.',
    example: `// Account structure\n{\n  lamports: 1000000,\n  data: Buffer<...>,\n  owner: PublicKey,\n  executable: false,\n  rentEpoch: 361\n}`,
    relatedTerms: ['rent', 'pda', 'space'],
  },
  {
    id: 'space',
    term: 'Space',
    category: 'Accounts',
    definition: 'The number of bytes allocated for an account\'s data field. Must be specified at account creation and determines the rent-exempt cost. Anchor calculates this from your struct definition.',
    whenToUse: 'When creating accounts with `init`. Calculate as: 8 (discriminator) + sum of field sizes. Anchor uses `#[account(init, space = 8 + MyStruct::INIT_SPACE)]`.',
    example: `#[account]\npub struct Counter {\n  pub count: u64,     // 8 bytes\n  pub authority: Pubkey, // 32 bytes\n}\n// Total space: 8 + 8 + 32 = 48 bytes`,
    relatedTerms: ['account', 'rent', 'discriminator'],
  },
  {
    id: 'discriminator',
    term: 'Discriminator',
    category: 'Development',
    definition: 'An 8-byte identifier prepended to every Anchor account\'s data. It\'s the first 8 bytes of the SHA-256 hash of the account\'s type name. Prevents deserialization of wrong account types.',
    whenToUse: 'Anchor handles this automatically. Be aware of it when calculating account space (always add 8 bytes) or when reading raw account data.',
    example: `// Anchor auto-generates discriminator\n// For "Counter" account: sha256("account:Counter")[0..8]`,
    relatedTerms: ['space', 'account', 'anchor'],
  },
  {
    id: 'instruction',
    term: 'Instruction',
    category: 'Transactions',
    definition: 'A single operation within a transaction. Contains the target program ID, a list of accounts the instruction will read/write, and serialized instruction data. Multiple instructions can be batched into one transaction.',
    whenToUse: 'Every interaction with a Solana program goes through instructions. Batch related operations into a single transaction for atomicity.',
    example: `const ix = new TransactionInstruction({\n  programId: myProgramId,\n  keys: [\n    { pubkey: user, isSigner: true, isWritable: true },\n  ],\n  data: Buffer.from([...]),\n});`,
    relatedTerms: ['transaction', 'cpi', 'signer'],
  },
  {
    id: 'transaction',
    term: 'Transaction',
    category: 'Transactions',
    definition: 'An atomic unit of execution on Solana containing one or more instructions. All instructions either succeed or fail together. Transactions have a 1232-byte size limit and require at least one signer.',
    whenToUse: 'Group related instructions into a single transaction for atomicity. If you exceed the size limit, use Versioned Transactions with Address Lookup Tables.',
    example: `const tx = new Transaction().add(ix1, ix2);\ntx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\ntx.feePayer = wallet.publicKey;\nawait wallet.signTransaction(tx);`,
    relatedTerms: ['instruction', 'blockhash', 'versioned-transaction'],
  },
  {
    id: 'blockhash',
    term: 'Blockhash',
    category: 'Transactions',
    definition: 'A recent hash from the Solana ledger that acts as a transaction\'s timestamp. Transactions with blockhashes older than ~60-90 seconds are rejected, preventing replay attacks.',
    whenToUse: 'Always fetch a fresh blockhash before submitting a transaction. Use `getLatestBlockhash()` and set `lastValidBlockHeight` for confirmation tracking.',
    example: `const { blockhash, lastValidBlockHeight } = \n  await connection.getLatestBlockhash();\ntx.recentBlockhash = blockhash;`,
    relatedTerms: ['transaction', 'slot'],
  },
  {
    id: 'versioned-transaction',
    term: 'Versioned Transaction',
    category: 'Transactions',
    definition: 'A newer transaction format (v0) that supports Address Lookup Tables (ALTs), allowing transactions to reference more accounts without exceeding the size limit. Essential for complex DeFi operations.',
    whenToUse: 'When your transaction needs more than ~35 accounts or exceeds the 1232-byte limit. Jupiter and most DeFi protocols return versioned transactions.',
    example: `import { VersionedTransaction } from '@solana/web3.js';\nconst tx = VersionedTransaction.deserialize(serializedTx);\nawait wallet.signTransaction(tx);`,
    relatedTerms: ['transaction', 'address-lookup-table'],
  },
  {
    id: 'address-lookup-table',
    term: 'Address Lookup Table',
    abbreviation: 'ALT',
    category: 'Transactions',
    definition: 'An on-chain table that stores frequently-used account addresses. Versioned transactions reference ALT entries by index (1 byte) instead of full pubkey (32 bytes), dramatically reducing transaction size.',
    whenToUse: 'When building complex transactions that reference many accounts. Most DEX aggregators use ALTs. Create your own for protocols with many repeated accounts.',
    example: `const lookupTable = (await connection.getAddressLookupTable(tableAddress)).value;\n// Use in VersionedTransaction.compile()`,
    relatedTerms: ['versioned-transaction', 'transaction'],
  },
  {
    id: 'slot',
    term: 'Slot',
    category: 'Consensus',
    definition: 'A time window (~400ms) during which a validator can produce a block. Slots are sequential and used to measure time on Solana. Not every slot produces a block (some are skipped).',
    whenToUse: 'For timing and ordering. Use slot numbers for relative ordering of events. Epoch = 432,000 slots (~2-3 days).',
    example: `const slot = await connection.getSlot();\nconsole.log('Current slot:', slot);`,
    relatedTerms: ['epoch', 'blockhash', 'validator'],
  },
  {
    id: 'epoch',
    term: 'Epoch',
    category: 'Consensus',
    definition: 'A period of 432,000 slots (~2-3 days) during which the validator schedule is fixed. Stake delegations take effect at epoch boundaries, and rewards are distributed at the end of each epoch.',
    whenToUse: 'Relevant for staking operations. Stake activation/deactivation takes 1 full epoch. Use `getEpochInfo()` to check current epoch progress.',
    example: `const epochInfo = await connection.getEpochInfo();\nconsole.log('Epoch:', epochInfo.epoch, 'Slot in epoch:', epochInfo.slotIndex);`,
    relatedTerms: ['slot', 'validator', 'stake'],
  },
  {
    id: 'validator',
    term: 'Validator',
    category: 'Consensus',
    definition: 'A node that participates in the Solana network by verifying transactions and producing blocks. Validators stake SOL and earn rewards. The leader schedule rotates validators for block production.',
    whenToUse: 'Understanding validators matters for staking (choosing where to delegate) and for RPC reliability (some validators run public RPC endpoints).',
    example: `const validators = await connection.getVoteAccounts();\nconsole.log('Active validators:', validators.current.length);`,
    relatedTerms: ['slot', 'epoch', 'stake'],
  },
  {
    id: 'spl-token',
    term: 'SPL Token',
    category: 'Tokens',
    definition: 'The standard token program on Solana (Solana Program Library). Handles creating, minting, transferring, and burning fungible and non-fungible tokens. Every token on Solana uses this program.',
    whenToUse: 'Any token operation — creating a new token, minting supply, transferring between wallets. Use Token-2022 for advanced features like transfer hooks.',
    example: `import { createMint, mintTo } from '@solana/spl-token';\n\nconst mint = await createMint(\n  connection, payer, authority, null, 9\n);\nawait mintTo(connection, payer, mint, tokenAccount, authority, 1000000000);`,
    relatedTerms: ['token-2022', 'mint', 'associated-token-account'],
  },
  {
    id: 'token-2022',
    term: 'Token-2022 (Token Extensions)',
    category: 'Tokens',
    definition: 'The next-generation token program with extensions like transfer fees, confidential transfers, interest-bearing tokens, permanent delegates, and transfer hooks. Backwards-compatible with SPL Token.',
    whenToUse: 'When you need features not available in the original SPL Token: royalty enforcement, compliance hooks, interest accrual, or non-transferable tokens.',
    example: `// Create a mint with transfer fee extension\nimport { createInitializeTransferFeeConfigInstruction } from '@solana/spl-token';`,
    relatedTerms: ['spl-token', 'mint', 'transfer-hook'],
  },
  {
    id: 'mint',
    term: 'Mint',
    category: 'Tokens',
    definition: 'An account that defines a token type. It stores the total supply, decimal places, and the mint authority (who can create new tokens). Each unique token on Solana has exactly one mint account.',
    whenToUse: 'When creating a new token or referencing an existing one. The mint address is the token\'s unique identifier (like a contract address on Ethereum).',
    example: `// USDC mint on mainnet\nconst USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');`,
    relatedTerms: ['spl-token', 'associated-token-account'],
  },
  {
    id: 'associated-token-account',
    term: 'Associated Token Account',
    abbreviation: 'ATA',
    category: 'Tokens',
    definition: 'A deterministically-derived token account for a specific wallet and mint. The ATA program ensures each wallet has exactly one token account per mint at a predictable address.',
    whenToUse: 'Always use ATAs for user-facing token operations. The address is derived from the wallet and mint, so you never need to store it separately.',
    example: `import { getAssociatedTokenAddress } from '@solana/spl-token';\n\nconst ata = await getAssociatedTokenAddress(mintPubkey, walletPubkey);\n// Always the same for this wallet + mint combination`,
    relatedTerms: ['mint', 'spl-token', 'pda'],
  },
  {
    id: 'amm',
    term: 'Automated Market Maker',
    abbreviation: 'AMM',
    category: 'DeFi',
    definition: 'A protocol that uses mathematical formulas (typically x*y=k) to price assets in a liquidity pool, enabling decentralized trading without order books. Examples: Orca, Raydium.',
    whenToUse: 'When providing or consuming liquidity for token swaps. Use Jupiter to aggregate across AMMs for best pricing.',
    example: `// Swap via Jupiter (aggregates across AMMs)\nconst quote = await jupiterApi.quoteGet({\n  inputMint: SOL_MINT,\n  outputMint: USDC_MINT,\n  amount: 1_000_000_000,\n});`,
    relatedTerms: ['liquidity-pool', 'slippage', 'impermanent-loss'],
  },
  {
    id: 'liquidity-pool',
    term: 'Liquidity Pool',
    abbreviation: 'LP',
    category: 'DeFi',
    definition: 'A smart contract holding reserves of two or more tokens that enables trading. Liquidity providers deposit tokens and earn fees from swaps. The pool\'s reserves determine the exchange rate.',
    whenToUse: 'When building or integrating with DEXs. Provide liquidity to earn trading fees, or use pools for token swaps.',
    example: `// Check pool reserves\nconst poolInfo = await fetchPoolData(poolAddress);\nconsole.log('Token A:', poolInfo.tokenAReserve);\nconsole.log('Token B:', poolInfo.tokenBReserve);`,
    relatedTerms: ['amm', 'impermanent-loss', 'tvl'],
  },
  {
    id: 'tvl',
    term: 'Total Value Locked',
    abbreviation: 'TVL',
    category: 'DeFi',
    definition: 'The total USD value of assets deposited in a DeFi protocol. TVL is a key metric for gauging protocol adoption and trust — higher TVL generally indicates more market confidence.',
    whenToUse: 'For evaluating DeFi protocols. Compare TVL across protocols to assess relative adoption. Track TVL changes as a signal of capital flows.',
    example: `// Fetch TVL from DeFi Llama\nconst response = await fetch('https://api.llama.fi/tvl/protocol-name');\nconst tvl = await response.json();`,
    relatedTerms: ['liquidity-pool', 'amm'],
  },
  {
    id: 'slippage',
    term: 'Slippage',
    category: 'DeFi',
    definition: 'The difference between the expected price of a trade and the actual execution price. Caused by price movement between submission and execution, or insufficient liquidity in the pool.',
    whenToUse: 'Always set slippage tolerance when executing swaps. 0.5% is typical for stable pairs; 1-3% for volatile pairs. Too low = failed transactions; too high = sandwich attack risk.',
    example: `// Set slippage to 50 basis points (0.5%)\nconst quote = await jupiterApi.quoteGet({\n  ...params,\n  slippageBps: 50,\n});`,
    relatedTerms: ['amm', 'mev'],
  },
  {
    id: 'mev',
    term: 'Maximal Extractable Value',
    abbreviation: 'MEV',
    category: 'DeFi',
    definition: 'Profit extracted by reordering, inserting, or censoring transactions within a block. On Solana, MEV primarily manifests as sandwich attacks (front-running + back-running a swap) and arbitrage.',
    whenToUse: 'Be aware of MEV when submitting large swaps. Use Jito tips for priority inclusion, or set tight slippage to minimize sandwich attack profit.',
    example: `// Use Jito for MEV-protected transactions\n// Tip validators for priority inclusion\nconst jitoTip = 10_000; // lamports`,
    relatedTerms: ['slippage', 'jito'],
  },
  {
    id: 'idl',
    term: 'Interface Definition Language',
    abbreviation: 'IDL',
    category: 'Development',
    definition: 'A JSON file generated by Anchor that describes a program\'s instructions, accounts, types, and errors. Clients use the IDL to auto-generate type-safe interaction code.',
    whenToUse: 'When building clients for Anchor programs. Import the IDL to get typed methods: `program.methods.initialize().accounts({...}).rpc()`.',
    example: `import idl from './my_program.json';\nconst program = new Program(idl, programId, provider);\nawait program.methods.initialize().accounts({...}).rpc();`,
    relatedTerms: ['anchor', 'instruction'],
  },
  {
    id: 'anchor',
    term: 'Anchor',
    category: 'Development',
    definition: 'The dominant framework for building Solana programs in Rust. Provides macros for account validation, serialization, error handling, and testing. Think of it as Rails for Solana.',
    whenToUse: 'For almost all new Solana programs. Reduces boilerplate by 60-80% compared to raw Solana SDK. Only skip Anchor for maximum compute optimization.',
    example: `#[program]\npub mod my_program {\n  pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n    ctx.accounts.counter.count = 0;\n    Ok(())\n  }\n}`,
    relatedTerms: ['idl', 'cpi', 'discriminator'],
  },
  {
    id: 'signer',
    term: 'Signer',
    category: 'Transactions',
    definition: 'An account that has cryptographically signed a transaction, proving ownership. Signers authorize state changes — e.g., transferring SOL requires the sender\'s signature.',
    whenToUse: 'Mark accounts as signers in instructions when the program needs to verify authority. In Anchor, use `Signer<\'info>` for required signers.',
    example: `#[derive(Accounts)]\npub struct Transfer<'info> {\n  #[account(mut)]\n  pub from: Signer<'info>, // Must sign the transaction\n  #[account(mut)]\n  pub to: SystemAccount<'info>,\n}`,
    relatedTerms: ['transaction', 'instruction', 'keypair'],
  },
  {
    id: 'keypair',
    term: 'Keypair',
    category: 'Accounts',
    definition: 'A pair of cryptographic keys (public + private) based on the Ed25519 curve. The public key serves as an account address; the private key proves ownership and enables signing.',
    whenToUse: 'For server-side signing (bots, scripts) or generating new accounts. Never expose private keys in client-side code — use wallet adapters instead.',
    example: `import { Keypair } from '@solana/web3.js';\nconst kp = Keypair.generate();\nconsole.log('Public:', kp.publicKey.toBase58());\n// NEVER log kp.secretKey in production!`,
    relatedTerms: ['signer', 'account', 'pda'],
  },
  {
    id: 'nft',
    term: 'Non-Fungible Token',
    abbreviation: 'NFT',
    category: 'NFTs',
    definition: 'A unique digital asset represented as a token with supply of 1 and 0 decimals. On Solana, NFTs follow the Metaplex Token Metadata standard and can include on-chain attributes, royalties, and collection grouping.',
    whenToUse: 'For unique digital assets — art, tickets, memberships, in-game items. Use Metaplex for standard NFTs or Bubblegum for compressed NFTs (cheaper at scale).',
    example: `// Fetch NFT metadata using Helius DAS API\nconst nft = await helius.rpc.getAsset({ id: mintAddress });\nconsole.log(nft.content.metadata.name);`,
    relatedTerms: ['metaplex', 'compressed-nft', 'mint'],
  },
  {
    id: 'compressed-nft',
    term: 'Compressed NFT',
    abbreviation: 'cNFT',
    category: 'NFTs',
    definition: 'NFTs stored using state compression (Merkle trees) instead of individual accounts. Reduces minting cost from ~$2 to ~$0.0005 per NFT. Data is stored off-chain with on-chain proof.',
    whenToUse: 'When minting at scale (10k+ NFTs). Gaming items, loyalty points, event tickets. Use the DAS API (Helius, Triton) to read compressed NFT data.',
    example: `// Minting 1M compressed NFTs costs ~$500\n// vs $2M for uncompressed NFTs\nimport { createTree, mintToCollectionV1 } from '@metaplex-foundation/mpl-bubblegum';`,
    relatedTerms: ['nft', 'state-compression', 'merkle-tree'],
  },
  {
    id: 'state-compression',
    term: 'State Compression',
    category: 'Infrastructure',
    definition: 'A technique that stores data off-chain while maintaining on-chain Merkle tree proofs for verification. Dramatically reduces costs for large datasets. Powers compressed NFTs and potentially other compressed state.',
    whenToUse: 'When you need to store millions of records cheaply. Currently used primarily for compressed NFTs via the Bubblegum program.',
    example: `// Create a Merkle tree for state compression\nconst tree = await createTree(umi, {\n  merkleTree,\n  maxDepth: 14,      // 16,384 leaves\n  maxBufferSize: 64,\n});`,
    relatedTerms: ['compressed-nft', 'merkle-tree'],
  },
  {
    id: 'merkle-tree',
    term: 'Merkle Tree',
    category: 'Infrastructure',
    definition: 'A binary tree where each leaf contains data and each parent node contains the hash of its children. Enables efficient proof-of-inclusion — you can verify a leaf exists without downloading the entire tree.',
    whenToUse: 'Understanding Merkle trees helps when working with state compression or building systems that need efficient data verification (airdrops, whitelists).',
    example: `// A tree with maxDepth=20 supports 1,048,576 leaves\n// Proof size is only 20 hashes regardless of total leaves`,
    relatedTerms: ['state-compression', 'compressed-nft'],
  },
  {
    id: 'rpc',
    term: 'Remote Procedure Call',
    abbreviation: 'RPC',
    category: 'Infrastructure',
    definition: 'The API interface for interacting with a Solana validator node. RPC endpoints handle requests like getBalance, sendTransaction, and getAccountInfo. Public endpoints exist but are rate-limited.',
    whenToUse: 'Every Solana app needs an RPC endpoint. Use public for development; switch to Helius, QuickNode, or Triton for production to avoid rate limits and get enhanced APIs.',
    example: `import { Connection } from '@solana/web3.js';\n// Development\nconst dev = new Connection('https://api.devnet.solana.com');\n// Production (use private RPC)\nconst prod = new Connection('https://rpc.helius.xyz/?api-key=YOUR_KEY');`,
    relatedTerms: ['validator', 'websocket'],
  },
  {
    id: 'multisig',
    term: 'Multisig',
    category: 'Governance',
    definition: 'A wallet that requires multiple signatures (M-of-N) to approve transactions. On Solana, Squads Protocol is the standard multisig implementation, supporting program upgrades, treasury management, and governance.',
    whenToUse: 'For protocol treasuries, program upgrade authorities, and any high-value operations. Production protocols should never have a single-key upgrade authority.',
    example: `// Create a 2-of-3 multisig with Squads\nconst multisig = await squads.createMultisig({\n  threshold: 2,\n  members: [memberA, memberB, memberC],\n});`,
    relatedTerms: ['governance', 'program-authority'],
  },
  {
    id: 'governance',
    term: 'Governance',
    category: 'Governance',
    definition: 'On-chain voting mechanisms that allow token holders to propose and vote on protocol changes. Solana uses SPL Governance (Realms) for DAO-style governance with delegation, quorums, and time-locks.',
    whenToUse: 'When building DAOs or decentralizing protocol control. Use Realms for standard governance or build custom governance with Anchor.',
    example: `// Realms governance\n// Create proposal → Community votes → Execute if passed\n// https://realms.today`,
    relatedTerms: ['multisig', 'dao', 'realms'],
  },
  {
    id: 'dao',
    term: 'Decentralized Autonomous Organization',
    abbreviation: 'DAO',
    category: 'Governance',
    definition: 'An organization governed by smart contracts and token-holder voting rather than traditional management. Members propose, vote on, and automatically execute decisions through on-chain governance.',
    whenToUse: 'When building community-governed protocols. Use SPL Governance (Realms) for a battle-tested implementation with council and community voting.',
    example: `// Popular Solana DAOs use Realms:\n// - Marinade Finance\n// - Mango Markets\n// - Jito\n// Visit realms.today to explore`,
    relatedTerms: ['governance', 'multisig', 'realms'],
  },
  {
    id: 'program-authority',
    term: 'Program Authority (Upgrade Authority)',
    category: 'Security',
    definition: 'The keypair or multisig authorized to upgrade a deployed Solana program. If set to null, the program becomes immutable — no further upgrades are possible.',
    whenToUse: 'Audit this before trusting a protocol. Production programs should use a multisig authority. Immutable programs are maximally trustworthy but cannot be patched.',
    example: `# Check upgrade authority\nsolana program show <PROGRAM_ID>\n# Transfer to multisig\nsolana program set-upgrade-authority <PROGRAM_ID> --new-upgrade-authority <MULTISIG>`,
    relatedTerms: ['multisig', 'governance'],
  },
  {
    id: 'sol',
    term: 'SOL',
    category: 'Tokens',
    definition: 'The native token of the Solana blockchain. Used for transaction fees, staking, and rent. SOL is divisible to 9 decimal places (1 SOL = 10^9 lamports).',
    whenToUse: 'Every Solana transaction requires SOL for fees (~0.000005 SOL per signature). Users need SOL in their wallet before interacting with any dApp.',
    example: `// Airdrop SOL on devnet for testing\nawait connection.requestAirdrop(publicKey, 2 * LAMPORTS_PER_SOL);`,
    relatedTerms: ['lamports', 'stake', 'rent'],
  },
  {
    id: 'stake',
    term: 'Stake / Staking',
    category: 'Consensus',
    definition: 'Delegating SOL to a validator to help secure the network. Stakers earn rewards (~6-8% APY) proportional to their stake. Delegated stake takes one epoch to activate and one to deactivate.',
    whenToUse: 'For earning yield on SOL holdings. Liquid staking (mSOL, jitoSOL, bSOL) lets you stake while keeping liquidity for DeFi.',
    example: `// Liquid staking with Marinade\n// Deposit SOL → Receive mSOL (staked SOL derivative)\n// mSOL accrues staking rewards automatically`,
    relatedTerms: ['validator', 'epoch', 'sol'],
  },
  {
    id: 'impermanent-loss',
    term: 'Impermanent Loss',
    abbreviation: 'IL',
    category: 'DeFi',
    definition: 'The loss in value a liquidity provider experiences when the price ratio of pooled tokens changes compared to simply holding them. Called "impermanent" because it reverses if prices return to the original ratio.',
    whenToUse: 'Evaluate IL risk before providing liquidity. Concentrated liquidity (Orca Whirlpools) amplifies both fees AND IL. Stable pairs have minimal IL.',
    example: `// If SOL doubles in price:\n// Holding: $200 worth\n// LP position: ~$183 worth (8.5% IL)\n// But you also earned trading fees`,
    relatedTerms: ['liquidity-pool', 'amm'],
  },
  {
    id: 'devnet',
    term: 'Devnet',
    category: 'Infrastructure',
    definition: 'Solana\'s development test network. Free SOL can be airdropped for testing. Programs deployed to devnet are separate from mainnet. Use for development and testing before mainnet deployment.',
    whenToUse: 'Always develop and test on devnet first. Use `solana config set --url devnet` to switch your CLI. Request airdrops for test SOL.',
    example: `// Connect to devnet\nconst connection = new Connection('https://api.devnet.solana.com');\n// Get free test SOL\nawait connection.requestAirdrop(pubkey, LAMPORTS_PER_SOL);`,
    relatedTerms: ['mainnet', 'rpc'],
  },
  {
    id: 'mainnet',
    term: 'Mainnet-Beta',
    category: 'Infrastructure',
    definition: 'Solana\'s production network where real value transactions occur. Called "mainnet-beta" historically. Use a private RPC endpoint for production apps to avoid rate limits on the public endpoint.',
    whenToUse: 'For production deployments. Always test thoroughly on devnet first. Use a dedicated RPC provider (Helius, QuickNode) for reliability.',
    example: `// Production connection with private RPC\nconst connection = new Connection(\n  'https://rpc.helius.xyz/?api-key=YOUR_KEY',\n  'confirmed'\n);`,
    relatedTerms: ['devnet', 'rpc'],
  },
  {
    id: 'priority-fees',
    term: 'Priority Fees',
    category: 'Transactions',
    definition: 'Optional fees added to a transaction to incentivize validators to process it faster. Measured in micro-lamports per compute unit. Essential during network congestion or for time-sensitive operations.',
    whenToUse: 'For time-sensitive transactions (arbitrage, liquidations) or during high congestion. Use `getRecentPrioritizationFees()` to estimate appropriate levels.',
    example: `import { ComputeBudgetProgram } from '@solana/web3.js';\nconst priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({\n  microLamports: 50_000, // Adjust based on network conditions\n});`,
    relatedTerms: ['compute-units', 'transaction'],
  },
  {
    id: 'compute-units',
    term: 'Compute Units',
    abbreviation: 'CU',
    category: 'Transactions',
    definition: 'A measure of computational resources consumed by a transaction. Each transaction has a budget (default 200k CU, max 1.4M CU). Programs that exceed their budget are halted. Optimizing CU usage reduces priority fees.',
    whenToUse: 'When optimizing program performance. Request only the CU you need with `setComputeUnitLimit()` to avoid overpaying priority fees.',
    example: `const computeLimitIx = ComputeBudgetProgram.setComputeUnitLimit({\n  units: 300_000, // Request specific CU budget\n});`,
    relatedTerms: ['priority-fees', 'transaction'],
  },
  {
    id: 'websocket',
    term: 'WebSocket (Subscriptions)',
    category: 'Infrastructure',
    definition: 'A persistent connection to a Solana RPC node for real-time updates. Subscribe to account changes, log messages, signatures, and slot updates without polling.',
    whenToUse: 'For real-time UIs — wallet balance updates, transaction confirmations, live price feeds. More efficient than polling for frequent updates.',
    example: `// Subscribe to account changes\nconnection.onAccountChange(publicKey, (accountInfo) => {\n  console.log('Account changed:', accountInfo.lamports);\n});`,
    relatedTerms: ['rpc'],
  },
  {
    id: 'transfer-hook',
    term: 'Transfer Hook',
    category: 'Tokens',
    definition: 'A Token-2022 extension that calls a custom program whenever a token is transferred. Enables royalty enforcement, compliance checks, transfer restrictions, and custom logic on every token movement.',
    whenToUse: 'When you need code to execute on every token transfer — e.g., enforcing creator royalties, KYC checks, or updating game state.',
    example: `// Transfer hooks are configured at mint creation\n// Every transfer() call will invoke your hook program\n// Use for: royalties, compliance, gaming mechanics`,
    relatedTerms: ['token-2022', 'spl-token'],
  },
  {
    id: 'realms',
    term: 'Realms',
    category: 'Governance',
    definition: 'The standard governance UI and tooling for Solana DAOs, built on SPL Governance. Supports council voting, community voting, delegation, and on-chain proposal execution.',
    whenToUse: 'When setting up governance for your protocol. Realms provides a ready-made UI at realms.today — no custom frontend needed for basic governance.',
    example: `// Visit realms.today to:\n// - Create a new DAO\n// - Manage proposals\n// - Delegate voting power\n// - Execute approved transactions`,
    relatedTerms: ['dao', 'governance', 'multisig'],
  },
];

export function getDictionaryByCategory(category: DictionaryCategory): DictionaryEntry[] {
  return dictionary.filter((e) => e.category === category);
}

export function searchDictionary(query: string): DictionaryEntry[] {
  const q = query.toLowerCase();
  return dictionary.filter(
    (e) =>
      e.term.toLowerCase().includes(q) ||
      (e.abbreviation && e.abbreviation.toLowerCase().includes(q)) ||
      e.definition.toLowerCase().includes(q) ||
      e.category.toLowerCase().includes(q)
  );
}
